{"mappings":"C,A,S,C,C,C,C,C,C,C,C,C,C,C,C,C,C,C,E,I,E,A,a,O,W,W,A,a,O,K,K,A,a,O,O,O,A,a,O,O,O,C,E,E,A,Y,O,C,C,E,E,C,C,E,C,E,E,C,E,C,E,E,E,K,E,C,E,E,A,a,O,Q,A,Y,O,O,O,E,O,O,C,I,C,Q,S,E,C,C,C,E,G,C,C,C,E,C,C,G,C,C,C,E,C,C,G,C,C,E,C,O,C,C,E,C,I,E,A,Y,O,C,C,E,E,C,C,E,C,G,C,G,E,O,E,E,C,G,G,E,O,E,E,C,G,G,G,A,U,O,E,O,E,G,I,E,A,M,uB,E,I,O,E,I,C,mB,C,C,E,O,C,S,C,E,I,E,C,C,E,C,E,C,E,C,O,A,M,E,E,C,E,E,K,C,C,E,I,E,C,C,E,C,I,E,M,C,G,C,C,E,C,E,C,I,C,E,O,C,E,E,E,O,C,E,C,O,C,C,E,C,O,C,S,E,C,E,I,E,E,O,C,G,M,A,C,I,E,C,E,E,E,C,C,E,e,C,C,E,E,M,C,S,C,E,I,C,E,C,E,I,C,M,C,E,I,C,O,C,E,I,C,O,C,C,C,E,E,O,C,E,E,K,C,E,E,M,C,E,E,O,C,K,E,E,S,C,K,E,E,S,C,K,E,E,C,C,E,E,Q,C,S,C,C,C,E,C,C,E,C,C,S,C,C,C,E,E,O,C,C,E,C,E,A,E,O,c,C,E,O,C,I,W,O,C,C,E,A,C,G,C,C,E,C,E,I,I,E,E,E,E,M,C,I,E,C,C,E,E,G,E,C,I,E,E,E,A,C,U,O,S,A,a,O,O,O,O,C,E,A,Y,O,Q,O,G,E,O,W,O,C,E,C,E,C,M,C,S,C,C,C,C,C,C,C,E,A,E,kD,iB,C,GCEA,IAAA,EAAA,EAAA,QAGA,EAAA,EAAA,8BAIA,IAAM,EAAM,GAAI,CAAA,EAAA,EAAA,IAAI,AAAJ,EAIhB,EAAI,OAAO,CAAC,CAAC,EAAK,KACjB,QAAQ,KAAK,CAAC,CAAA,EAAG,EAAA,CAAK,EAEf,EAAE,IAAI,CAAC,kBAAmB,OAKlC,EAAI,QAAQ,CAAC,AAAC,IACb,QAAQ,GAAG,CAAC,gBAAiB,EAAE,GAAG,CAAC,GAAG,EAKtC,IAAM,EAAS,IAAI,IAAI,WAAY,EAAE,GAAG,CAAC,GAAG,EAC5C,OAAO,EAAE,GAAG,CAAC,MAAM,CAAC,KA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","sources":["<anon>","A-backend/cloudflare--worker/module/src/index.ts","node_modules/hono/dist/index.js","node_modules/hono/dist/hono.js","node_modules/hono/dist/hono-base.js","node_modules/hono/dist/compose.js","node_modules/@parcel/transformer-js/src/esmodule-helpers.js","node_modules/hono/dist/context.js","node_modules/hono/dist/request.js","node_modules/hono/dist/utils/body.js","node_modules/hono/dist/utils/url.js","node_modules/hono/dist/utils/html.js","node_modules/hono/dist/router.js","node_modules/hono/dist/utils/constants.js","node_modules/hono/dist/router/reg-exp-router/index.js","node_modules/hono/dist/router/reg-exp-router/router.js","node_modules/hono/dist/router/reg-exp-router/node.js","node_modules/hono/dist/router/reg-exp-router/trie.js","node_modules/hono/dist/router/smart-router/index.js","node_modules/hono/dist/router/smart-router/router.js","node_modules/hono/dist/router/trie-router/index.js","node_modules/hono/dist/router/trie-router/router.js","node_modules/hono/dist/router/trie-router/node.js","A-backend/cloudflare--worker/module/src/endpoints/users/index.ts"],"sourcesContent":["// modules are defined as an array\n// [ module function, map of requires ]\n//\n// map of requires is short require name -> numeric require\n//\n// anything defined in a previous bundle is accessed via the\n// orig method which is the require for previous bundles\n\n(function (\n  modules,\n  entry,\n  mainEntry,\n  parcelRequireName,\n  externals,\n  distDir,\n  publicUrl,\n  devServer\n) {\n  /* eslint-disable no-undef */\n  var globalObject =\n    typeof globalThis !== 'undefined'\n      ? globalThis\n      : typeof self !== 'undefined'\n      ? self\n      : typeof window !== 'undefined'\n      ? window\n      : typeof global !== 'undefined'\n      ? global\n      : {};\n  /* eslint-enable no-undef */\n\n  // Save the require from previous bundle to this closure if any\n  var previousRequire =\n    typeof globalObject[parcelRequireName] === 'function' &&\n    globalObject[parcelRequireName];\n\n  var importMap = previousRequire.i || {};\n  var cache = previousRequire.cache || {};\n  // Do not use `require` to prevent Webpack from trying to bundle this call\n  var nodeRequire =\n    typeof module !== 'undefined' &&\n    typeof module.require === 'function' &&\n    module.require.bind(module);\n\n  function newRequire(name, jumped) {\n    if (!cache[name]) {\n      if (!modules[name]) {\n        if (externals[name]) {\n          return externals[name];\n        }\n        // if we cannot find the module within our internal map or\n        // cache jump to the current global require ie. the last bundle\n        // that was added to the page.\n        var currentRequire =\n          typeof globalObject[parcelRequireName] === 'function' &&\n          globalObject[parcelRequireName];\n        if (!jumped && currentRequire) {\n          return currentRequire(name, true);\n        }\n\n        // If there are other bundles on this page the require from the\n        // previous one is saved to 'previousRequire'. Repeat this as\n        // many times as there are bundles until the module is found or\n        // we exhaust the require chain.\n        if (previousRequire) {\n          return previousRequire(name, true);\n        }\n\n        // Try the node require function if it exists.\n        if (nodeRequire && typeof name === 'string') {\n          return nodeRequire(name);\n        }\n\n        var err = new Error(\"Cannot find module '\" + name + \"'\");\n        err.code = 'MODULE_NOT_FOUND';\n        throw err;\n      }\n\n      localRequire.resolve = resolve;\n      localRequire.cache = {};\n\n      var module = (cache[name] = new newRequire.Module(name));\n\n      modules[name][0].call(\n        module.exports,\n        localRequire,\n        module,\n        module.exports,\n        globalObject\n      );\n    }\n\n    return cache[name].exports;\n\n    function localRequire(x) {\n      var res = localRequire.resolve(x);\n      return res === false ? {} : newRequire(res);\n    }\n\n    function resolve(x) {\n      var id = modules[name][1][x];\n      return id != null ? id : x;\n    }\n  }\n\n  function Module(moduleName) {\n    this.id = moduleName;\n    this.bundle = newRequire;\n    this.require = nodeRequire;\n    this.exports = {};\n  }\n\n  newRequire.isParcelRequire = true;\n  newRequire.Module = Module;\n  newRequire.modules = modules;\n  newRequire.cache = cache;\n  newRequire.parent = previousRequire;\n  newRequire.distDir = distDir;\n  newRequire.publicUrl = publicUrl;\n  newRequire.devServer = devServer;\n  newRequire.i = importMap;\n  newRequire.register = function (id, exports) {\n    modules[id] = [\n      function (require, module) {\n        module.exports = exports;\n      },\n      {},\n    ];\n  };\n\n  // Only insert newRequire.load when it is actually used.\n  // The code in this file is linted against ES5, so dynamic import is not allowed.\n  // INSERT_LOAD_HERE\n\n  Object.defineProperty(newRequire, 'root', {\n    get: function () {\n      return globalObject[parcelRequireName];\n    },\n  });\n\n  globalObject[parcelRequireName] = newRequire;\n\n  for (var i = 0; i < entry.length; i++) {\n    newRequire(entry[i]);\n  }\n\n  if (mainEntry) {\n    // Expose entry point to Node, AMD or browser globals\n    // Based on https://github.com/ForbesLindesay/umd/blob/master/template.js\n    var mainExports = newRequire(mainEntry);\n\n    // CommonJS\n    if (typeof exports === 'object' && typeof module !== 'undefined') {\n      module.exports = mainExports;\n\n      // RequireJS\n    } else if (typeof define === 'function' && define.amd) {\n      define(function () {\n        return mainExports;\n      });\n    }\n  }\n})({\"dDS2A\":[function(require,module,exports,__globalThis) {\n//import { dumpanyprettified } from '@offirmo-private/prettify-any'\nvar parcelHelpers = require(\"@parcel/transformer-js/src/esmodule-helpers.js\");\nparcelHelpers.defineInteropFlag(exports);\nvar _hono = require(\"hono\");\n//import { type Bindings } from './types.ts'\nvar _indexTs = require(\"./endpoints/users/index.ts\");\n/////////////////////////////////////////////////\nconst app = new (0, _hono.Hono)();\n/////////////////////////////////////////////////\napp.onError((err, c)=>{\n    console.error(`${err}`);\n    return c.text('Error from Hono', 500);\n});\n/////////////////////////////////////////////////\napp.notFound((c)=>{\n    console.log(`Hono notFound`, c.req.url);\n    //debugger\n    //return c.text('404 from Hono!', 404)\n    const url404 = new URL('404.html', c.req.url);\n    return c.env.ASSETS.fetch(url404);\n});\n/////////////////////////////////////////////////\napp.use(async (c, next)=>{\n    console.log(`Hono before`, c.req.url);\n    await next();\n    console.log(`Hono after`, c.req.url);\n});\napp.get('/api', (c)=>c.text(`Hello Cloudflare Workers! ${(0, _indexTs.FOO)}`));\napp.get('/test', (c)=>c.text('Hono!'));\n/*\napp.all('*', c => {\n\tconsole.log(`Hono All`, c.req.url)\n\n\t// https://developers.cloudflare.com/workers/static-assets/binding/#runtime-api-reference\n\t//return c.env.ASSETS.fetch(c.req.raw);\n})*/ exports.default = app;\n\n},{\"hono\":\"dpYm7\",\"./endpoints/users/index.ts\":\"6Gli9\",\"@parcel/transformer-js/src/esmodule-helpers.js\":\"dt6k9\"}],\"dpYm7\":[function(require,module,exports,__globalThis) {\n// src/index.ts\nvar parcelHelpers = require(\"@parcel/transformer-js/src/esmodule-helpers.js\");\nparcelHelpers.defineInteropFlag(exports);\nparcelHelpers.export(exports, \"Hono\", ()=>(0, _honoJs.Hono));\nvar _honoJs = require(\"./hono.js\");\n\n},{\"./hono.js\":\"3ehAE\",\"@parcel/transformer-js/src/esmodule-helpers.js\":\"dt6k9\"}],\"3ehAE\":[function(require,module,exports,__globalThis) {\n// src/hono.ts\nvar parcelHelpers = require(\"@parcel/transformer-js/src/esmodule-helpers.js\");\nparcelHelpers.defineInteropFlag(exports);\nparcelHelpers.export(exports, \"Hono\", ()=>Hono);\nvar _honoBaseJs = require(\"./hono-base.js\");\nvar _indexJs = require(\"./router/reg-exp-router/index.js\");\nvar _indexJs1 = require(\"./router/smart-router/index.js\");\nvar _indexJs2 = require(\"./router/trie-router/index.js\");\nvar Hono = class extends (0, _honoBaseJs.HonoBase) {\n    constructor(options = {}){\n        super(options);\n        this.router = options.router ?? new (0, _indexJs1.SmartRouter)({\n            routers: [\n                new (0, _indexJs.RegExpRouter)(),\n                new (0, _indexJs2.TrieRouter)()\n            ]\n        });\n    }\n};\n\n},{\"./hono-base.js\":\"cubCA\",\"./router/reg-exp-router/index.js\":\"g63tS\",\"./router/smart-router/index.js\":\"7xsbc\",\"./router/trie-router/index.js\":\"3vG3W\",\"@parcel/transformer-js/src/esmodule-helpers.js\":\"dt6k9\"}],\"cubCA\":[function(require,module,exports,__globalThis) {\n// src/hono-base.ts\nvar parcelHelpers = require(\"@parcel/transformer-js/src/esmodule-helpers.js\");\nparcelHelpers.defineInteropFlag(exports);\nparcelHelpers.export(exports, \"HonoBase\", ()=>Hono);\nvar _composeJs = require(\"./compose.js\");\nvar _contextJs = require(\"./context.js\");\nvar _routerJs = require(\"./router.js\");\nvar _constantsJs = require(\"./utils/constants.js\");\nvar _urlJs = require(\"./utils/url.js\");\nvar notFoundHandler = (c)=>{\n    return c.text(\"404 Not Found\", 404);\n};\nvar errorHandler = (err, c)=>{\n    if (\"getResponse\" in err) {\n        const res = err.getResponse();\n        return c.newResponse(res.body, res);\n    }\n    console.error(err);\n    return c.text(\"Internal Server Error\", 500);\n};\nvar Hono = class {\n    get;\n    post;\n    put;\n    delete;\n    options;\n    patch;\n    all;\n    on;\n    use;\n    router;\n    getPath;\n    _basePath = \"/\";\n    #path = \"/\";\n    routes = [];\n    constructor(options = {}){\n        const allMethods = [\n            ...(0, _routerJs.METHODS),\n            (0, _routerJs.METHOD_NAME_ALL_LOWERCASE)\n        ];\n        allMethods.forEach((method)=>{\n            this[method] = (args1, ...args)=>{\n                if (typeof args1 === \"string\") this.#path = args1;\n                else this.#addRoute(method, this.#path, args1);\n                args.forEach((handler)=>{\n                    this.#addRoute(method, this.#path, handler);\n                });\n                return this;\n            };\n        });\n        this.on = (method, path, ...handlers)=>{\n            for (const p of [\n                path\n            ].flat()){\n                this.#path = p;\n                for (const m of [\n                    method\n                ].flat())handlers.map((handler)=>{\n                    this.#addRoute(m.toUpperCase(), this.#path, handler);\n                });\n            }\n            return this;\n        };\n        this.use = (arg1, ...handlers)=>{\n            if (typeof arg1 === \"string\") this.#path = arg1;\n            else {\n                this.#path = \"*\";\n                handlers.unshift(arg1);\n            }\n            handlers.forEach((handler)=>{\n                this.#addRoute((0, _routerJs.METHOD_NAME_ALL), this.#path, handler);\n            });\n            return this;\n        };\n        const { strict, ...optionsWithoutStrict } = options;\n        Object.assign(this, optionsWithoutStrict);\n        this.getPath = strict ?? true ? options.getPath ?? (0, _urlJs.getPath) : (0, _urlJs.getPathNoStrict);\n    }\n    #clone() {\n        const clone = new Hono({\n            router: this.router,\n            getPath: this.getPath\n        });\n        clone.errorHandler = this.errorHandler;\n        clone.#notFoundHandler = this.#notFoundHandler;\n        clone.routes = this.routes;\n        return clone;\n    }\n    #notFoundHandler = notFoundHandler;\n    errorHandler = errorHandler;\n    route(path, app) {\n        const subApp = this.basePath(path);\n        app.routes.map((r)=>{\n            let handler;\n            if (app.errorHandler === errorHandler) handler = r.handler;\n            else {\n                handler = async (c, next)=>(await (0, _composeJs.compose)([], app.errorHandler)(c, ()=>r.handler(c, next))).res;\n                handler[0, _constantsJs.COMPOSED_HANDLER] = r.handler;\n            }\n            subApp.#addRoute(r.method, r.path, handler);\n        });\n        return this;\n    }\n    basePath(path) {\n        const subApp = this.#clone();\n        subApp._basePath = (0, _urlJs.mergePath)(this._basePath, path);\n        return subApp;\n    }\n    onError = (handler)=>{\n        this.errorHandler = handler;\n        return this;\n    };\n    notFound = (handler)=>{\n        this.#notFoundHandler = handler;\n        return this;\n    };\n    mount(path, applicationHandler, options) {\n        let replaceRequest;\n        let optionHandler;\n        if (options) {\n            if (typeof options === \"function\") optionHandler = options;\n            else {\n                optionHandler = options.optionHandler;\n                if (options.replaceRequest === false) replaceRequest = (request)=>request;\n                else replaceRequest = options.replaceRequest;\n            }\n        }\n        const getOptions = optionHandler ? (c)=>{\n            const options2 = optionHandler(c);\n            return Array.isArray(options2) ? options2 : [\n                options2\n            ];\n        } : (c)=>{\n            let executionContext = void 0;\n            try {\n                executionContext = c.executionCtx;\n            } catch  {}\n            return [\n                c.env,\n                executionContext\n            ];\n        };\n        replaceRequest ||= (()=>{\n            const mergedPath = (0, _urlJs.mergePath)(this._basePath, path);\n            const pathPrefixLength = mergedPath === \"/\" ? 0 : mergedPath.length;\n            return (request)=>{\n                const url = new URL(request.url);\n                url.pathname = url.pathname.slice(pathPrefixLength) || \"/\";\n                return new Request(url, request);\n            };\n        })();\n        const handler = async (c, next)=>{\n            const res = await applicationHandler(replaceRequest(c.req.raw), ...getOptions(c));\n            if (res) return res;\n            await next();\n        };\n        this.#addRoute((0, _routerJs.METHOD_NAME_ALL), (0, _urlJs.mergePath)(path, \"*\"), handler);\n        return this;\n    }\n    #addRoute(method, path, handler) {\n        method = method.toUpperCase();\n        path = (0, _urlJs.mergePath)(this._basePath, path);\n        const r = {\n            path,\n            method,\n            handler\n        };\n        this.router.add(method, path, [\n            handler,\n            r\n        ]);\n        this.routes.push(r);\n    }\n    #handleError(err, c) {\n        if (err instanceof Error) return this.errorHandler(err, c);\n        throw err;\n    }\n    #dispatch(request, executionCtx, env, method) {\n        if (method === \"HEAD\") return (async ()=>new Response(null, await this.#dispatch(request, executionCtx, env, \"GET\")))();\n        const path = this.getPath(request, {\n            env\n        });\n        const matchResult = this.router.match(method, path);\n        const c = new (0, _contextJs.Context)(request, {\n            path,\n            matchResult,\n            env,\n            executionCtx,\n            notFoundHandler: this.#notFoundHandler\n        });\n        if (matchResult[0].length === 1) {\n            let res;\n            try {\n                res = matchResult[0][0][0][0](c, async ()=>{\n                    c.res = await this.#notFoundHandler(c);\n                });\n            } catch (err) {\n                return this.#handleError(err, c);\n            }\n            return res instanceof Promise ? res.then((resolved)=>resolved || (c.finalized ? c.res : this.#notFoundHandler(c))).catch((err)=>this.#handleError(err, c)) : res ?? this.#notFoundHandler(c);\n        }\n        const composed = (0, _composeJs.compose)(matchResult[0], this.errorHandler, this.#notFoundHandler);\n        return (async ()=>{\n            try {\n                const context = await composed(c);\n                if (!context.finalized) throw new Error(\"Context is not finalized. Did you forget to return a Response object or `await next()`?\");\n                return context.res;\n            } catch (err) {\n                return this.#handleError(err, c);\n            }\n        })();\n    }\n    fetch = (request, ...rest)=>{\n        return this.#dispatch(request, rest[1], rest[0], request.method);\n    };\n    request = (input, requestInit, Env, executionCtx)=>{\n        if (input instanceof Request) return this.fetch(requestInit ? new Request(input, requestInit) : input, Env, executionCtx);\n        input = input.toString();\n        return this.fetch(new Request(/^https?:\\/\\//.test(input) ? input : `http://localhost${(0, _urlJs.mergePath)(\"/\", input)}`, requestInit), Env, executionCtx);\n    };\n    fire = ()=>{\n        addEventListener(\"fetch\", (event)=>{\n            event.respondWith(this.#dispatch(event.request, event, void 0, event.request.method));\n        });\n    };\n};\n\n},{\"./compose.js\":\"scXAs\",\"./context.js\":\"7sFky\",\"./router.js\":\"2P7Cv\",\"./utils/constants.js\":\"htJPb\",\"./utils/url.js\":\"lo13I\",\"@parcel/transformer-js/src/esmodule-helpers.js\":\"dt6k9\"}],\"scXAs\":[function(require,module,exports,__globalThis) {\n// src/compose.ts\nvar parcelHelpers = require(\"@parcel/transformer-js/src/esmodule-helpers.js\");\nparcelHelpers.defineInteropFlag(exports);\nparcelHelpers.export(exports, \"compose\", ()=>compose);\nvar compose = (middleware, onError, onNotFound)=>{\n    return (context, next)=>{\n        let index = -1;\n        return dispatch(0);\n        async function dispatch(i) {\n            if (i <= index) throw new Error(\"next() called multiple times\");\n            index = i;\n            let res;\n            let isError = false;\n            let handler;\n            if (middleware[i]) {\n                handler = middleware[i][0][0];\n                context.req.routeIndex = i;\n            } else handler = i === middleware.length && next || void 0;\n            if (handler) try {\n                res = await handler(context, ()=>dispatch(i + 1));\n            } catch (err) {\n                if (err instanceof Error && onError) {\n                    context.error = err;\n                    res = await onError(err, context);\n                    isError = true;\n                } else throw err;\n            }\n            else if (context.finalized === false && onNotFound) res = await onNotFound(context);\n            if (res && (context.finalized === false || isError)) context.res = res;\n            return context;\n        }\n    };\n};\n\n},{\"@parcel/transformer-js/src/esmodule-helpers.js\":\"dt6k9\"}],\"dt6k9\":[function(require,module,exports,__globalThis) {\nexports.interopDefault = function(a) {\n    return a && a.__esModule ? a : {\n        default: a\n    };\n};\nexports.defineInteropFlag = function(a) {\n    Object.defineProperty(a, '__esModule', {\n        value: true\n    });\n};\nexports.exportAll = function(source, dest) {\n    Object.keys(source).forEach(function(key) {\n        if (key === 'default' || key === '__esModule' || Object.prototype.hasOwnProperty.call(dest, key)) return;\n        Object.defineProperty(dest, key, {\n            enumerable: true,\n            get: function() {\n                return source[key];\n            }\n        });\n    });\n    return dest;\n};\nexports.export = function(dest, destName, get) {\n    Object.defineProperty(dest, destName, {\n        enumerable: true,\n        get: get\n    });\n};\n\n},{}],\"7sFky\":[function(require,module,exports,__globalThis) {\n// src/context.ts\nvar parcelHelpers = require(\"@parcel/transformer-js/src/esmodule-helpers.js\");\nparcelHelpers.defineInteropFlag(exports);\nparcelHelpers.export(exports, \"Context\", ()=>Context);\nparcelHelpers.export(exports, \"TEXT_PLAIN\", ()=>TEXT_PLAIN);\nvar _requestJs = require(\"./request.js\");\nvar _htmlJs = require(\"./utils/html.js\");\nvar TEXT_PLAIN = \"text/plain; charset=UTF-8\";\nvar setHeaders = (headers, map = {})=>{\n    for (const key of Object.keys(map))headers.set(key, map[key]);\n    return headers;\n};\nvar Context = class {\n    #rawRequest;\n    #req;\n    env = {};\n    #var;\n    finalized = false;\n    error;\n    #status = 200;\n    #executionCtx;\n    #headers;\n    #preparedHeaders;\n    #res;\n    #isFresh = true;\n    #layout;\n    #renderer;\n    #notFoundHandler;\n    #matchResult;\n    #path;\n    constructor(req, options){\n        this.#rawRequest = req;\n        if (options) {\n            this.#executionCtx = options.executionCtx;\n            this.env = options.env;\n            this.#notFoundHandler = options.notFoundHandler;\n            this.#path = options.path;\n            this.#matchResult = options.matchResult;\n        }\n    }\n    get req() {\n        this.#req ??= new (0, _requestJs.HonoRequest)(this.#rawRequest, this.#path, this.#matchResult);\n        return this.#req;\n    }\n    get event() {\n        if (this.#executionCtx && \"respondWith\" in this.#executionCtx) return this.#executionCtx;\n        else throw Error(\"This context has no FetchEvent\");\n    }\n    get executionCtx() {\n        if (this.#executionCtx) return this.#executionCtx;\n        else throw Error(\"This context has no ExecutionContext\");\n    }\n    get res() {\n        this.#isFresh = false;\n        return this.#res ||= new Response(\"404 Not Found\", {\n            status: 404\n        });\n    }\n    set res(_res) {\n        this.#isFresh = false;\n        if (this.#res && _res) {\n            _res = new Response(_res.body, _res);\n            for (const [k, v] of this.#res.headers.entries()){\n                if (k === \"content-type\") continue;\n                if (k === \"set-cookie\") {\n                    const cookies = this.#res.headers.getSetCookie();\n                    _res.headers.delete(\"set-cookie\");\n                    for (const cookie of cookies)_res.headers.append(\"set-cookie\", cookie);\n                } else _res.headers.set(k, v);\n            }\n        }\n        this.#res = _res;\n        this.finalized = true;\n    }\n    render = (...args)=>{\n        this.#renderer ??= (content)=>this.html(content);\n        return this.#renderer(...args);\n    };\n    setLayout = (layout)=>this.#layout = layout;\n    getLayout = ()=>this.#layout;\n    setRenderer = (renderer)=>{\n        this.#renderer = renderer;\n    };\n    header = (name, value, options)=>{\n        if (this.finalized) this.#res = new Response(this.#res.body, this.#res);\n        if (value === void 0) {\n            if (this.#headers) this.#headers.delete(name);\n            else if (this.#preparedHeaders) delete this.#preparedHeaders[name.toLocaleLowerCase()];\n            if (this.finalized) this.res.headers.delete(name);\n            return;\n        }\n        if (options?.append) {\n            if (!this.#headers) {\n                this.#isFresh = false;\n                this.#headers = new Headers(this.#preparedHeaders);\n                this.#preparedHeaders = {};\n            }\n            this.#headers.append(name, value);\n        } else if (this.#headers) this.#headers.set(name, value);\n        else {\n            this.#preparedHeaders ??= {};\n            this.#preparedHeaders[name.toLowerCase()] = value;\n        }\n        if (this.finalized) {\n            if (options?.append) this.res.headers.append(name, value);\n            else this.res.headers.set(name, value);\n        }\n    };\n    status = (status)=>{\n        this.#isFresh = false;\n        this.#status = status;\n    };\n    set = (key, value)=>{\n        this.#var ??= /* @__PURE__ */ new Map();\n        this.#var.set(key, value);\n    };\n    get = (key)=>{\n        return this.#var ? this.#var.get(key) : void 0;\n    };\n    get var() {\n        if (!this.#var) return {};\n        return Object.fromEntries(this.#var);\n    }\n    #newResponse(data, arg, headers) {\n        if (this.#isFresh && !headers && !arg && this.#status === 200) return new Response(data, {\n            headers: this.#preparedHeaders\n        });\n        if (arg && typeof arg !== \"number\") {\n            const header = new Headers(arg.headers);\n            if (this.#headers) this.#headers.forEach((v, k)=>{\n                if (k === \"set-cookie\") header.append(k, v);\n                else header.set(k, v);\n            });\n            const headers2 = setHeaders(header, this.#preparedHeaders);\n            return new Response(data, {\n                headers: headers2,\n                status: arg.status ?? this.#status\n            });\n        }\n        const status = typeof arg === \"number\" ? arg : this.#status;\n        this.#preparedHeaders ??= {};\n        this.#headers ??= new Headers();\n        setHeaders(this.#headers, this.#preparedHeaders);\n        if (this.#res) {\n            this.#res.headers.forEach((v, k)=>{\n                if (k === \"set-cookie\") this.#headers?.append(k, v);\n                else this.#headers?.set(k, v);\n            });\n            setHeaders(this.#headers, this.#preparedHeaders);\n        }\n        headers ??= {};\n        for (const [k, v] of Object.entries(headers))if (typeof v === \"string\") this.#headers.set(k, v);\n        else {\n            this.#headers.delete(k);\n            for (const v2 of v)this.#headers.append(k, v2);\n        }\n        return new Response(data, {\n            status,\n            headers: this.#headers\n        });\n    }\n    newResponse = (...args)=>this.#newResponse(...args);\n    body = (data, arg, headers)=>{\n        return typeof arg === \"number\" ? this.#newResponse(data, arg, headers) : this.#newResponse(data, arg);\n    };\n    text = (text, arg, headers)=>{\n        if (!this.#preparedHeaders) {\n            if (this.#isFresh && !headers && !arg) return new Response(text);\n            this.#preparedHeaders = {};\n        }\n        this.#preparedHeaders[\"content-type\"] = TEXT_PLAIN;\n        if (typeof arg === \"number\") return this.#newResponse(text, arg, headers);\n        return this.#newResponse(text, arg);\n    };\n    json = (object, arg, headers)=>{\n        const body = JSON.stringify(object);\n        this.#preparedHeaders ??= {};\n        this.#preparedHeaders[\"content-type\"] = \"application/json\";\n        return typeof arg === \"number\" ? this.#newResponse(body, arg, headers) : this.#newResponse(body, arg);\n    };\n    html = (html, arg, headers)=>{\n        this.#preparedHeaders ??= {};\n        this.#preparedHeaders[\"content-type\"] = \"text/html; charset=UTF-8\";\n        if (typeof html === \"object\") return (0, _htmlJs.resolveCallback)(html, (0, _htmlJs.HtmlEscapedCallbackPhase).Stringify, false, {}).then((html2)=>{\n            return typeof arg === \"number\" ? this.#newResponse(html2, arg, headers) : this.#newResponse(html2, arg);\n        });\n        return typeof arg === \"number\" ? this.#newResponse(html, arg, headers) : this.#newResponse(html, arg);\n    };\n    redirect = (location, status)=>{\n        this.#headers ??= new Headers();\n        this.#headers.set(\"Location\", String(location));\n        return this.newResponse(null, status ?? 302);\n    };\n    notFound = ()=>{\n        this.#notFoundHandler ??= ()=>new Response();\n        return this.#notFoundHandler(this);\n    };\n};\n\n},{\"./request.js\":\"jXU57\",\"./utils/html.js\":\"dRgLc\",\"@parcel/transformer-js/src/esmodule-helpers.js\":\"dt6k9\"}],\"jXU57\":[function(require,module,exports,__globalThis) {\n// src/request.ts\nvar parcelHelpers = require(\"@parcel/transformer-js/src/esmodule-helpers.js\");\nparcelHelpers.defineInteropFlag(exports);\nparcelHelpers.export(exports, \"HonoRequest\", ()=>HonoRequest);\nvar _bodyJs = require(\"./utils/body.js\");\nvar _urlJs = require(\"./utils/url.js\");\nvar tryDecodeURIComponent = (str)=>(0, _urlJs.tryDecode)(str, (0, _urlJs.decodeURIComponent_));\nvar HonoRequest = class {\n    raw;\n    #validatedData;\n    #matchResult;\n    routeIndex = 0;\n    path;\n    bodyCache = {};\n    constructor(request, path = \"/\", matchResult = [\n        []\n    ]){\n        this.raw = request;\n        this.path = path;\n        this.#matchResult = matchResult;\n        this.#validatedData = {};\n    }\n    param(key) {\n        return key ? this.#getDecodedParam(key) : this.#getAllDecodedParams();\n    }\n    #getDecodedParam(key) {\n        const paramKey = this.#matchResult[0][this.routeIndex][1][key];\n        const param = this.#getParamValue(paramKey);\n        return param ? /\\%/.test(param) ? tryDecodeURIComponent(param) : param : void 0;\n    }\n    #getAllDecodedParams() {\n        const decoded = {};\n        const keys = Object.keys(this.#matchResult[0][this.routeIndex][1]);\n        for (const key of keys){\n            const value = this.#getParamValue(this.#matchResult[0][this.routeIndex][1][key]);\n            if (value && typeof value === \"string\") decoded[key] = /\\%/.test(value) ? tryDecodeURIComponent(value) : value;\n        }\n        return decoded;\n    }\n    #getParamValue(paramKey) {\n        return this.#matchResult[1] ? this.#matchResult[1][paramKey] : paramKey;\n    }\n    query(key) {\n        return (0, _urlJs.getQueryParam)(this.url, key);\n    }\n    queries(key) {\n        return (0, _urlJs.getQueryParams)(this.url, key);\n    }\n    header(name) {\n        if (name) return this.raw.headers.get(name) ?? void 0;\n        const headerData = {};\n        this.raw.headers.forEach((value, key)=>{\n            headerData[key] = value;\n        });\n        return headerData;\n    }\n    async parseBody(options) {\n        return this.bodyCache.parsedBody ??= await (0, _bodyJs.parseBody)(this, options);\n    }\n    #cachedBody = (key)=>{\n        const { bodyCache, raw } = this;\n        const cachedBody = bodyCache[key];\n        if (cachedBody) return cachedBody;\n        const anyCachedKey = Object.keys(bodyCache)[0];\n        if (anyCachedKey) return bodyCache[anyCachedKey].then((body)=>{\n            if (anyCachedKey === \"json\") body = JSON.stringify(body);\n            return new Response(body)[key]();\n        });\n        return bodyCache[key] = raw[key]();\n    };\n    json() {\n        return this.#cachedBody(\"json\");\n    }\n    text() {\n        return this.#cachedBody(\"text\");\n    }\n    arrayBuffer() {\n        return this.#cachedBody(\"arrayBuffer\");\n    }\n    blob() {\n        return this.#cachedBody(\"blob\");\n    }\n    formData() {\n        return this.#cachedBody(\"formData\");\n    }\n    addValidatedData(target, data) {\n        this.#validatedData[target] = data;\n    }\n    valid(target) {\n        return this.#validatedData[target];\n    }\n    get url() {\n        return this.raw.url;\n    }\n    get method() {\n        return this.raw.method;\n    }\n    get matchedRoutes() {\n        return this.#matchResult[0].map(([[, route]])=>route);\n    }\n    get routePath() {\n        return this.#matchResult[0].map(([[, route]])=>route)[this.routeIndex].path;\n    }\n};\n\n},{\"./utils/body.js\":\"jXnid\",\"./utils/url.js\":\"lo13I\",\"@parcel/transformer-js/src/esmodule-helpers.js\":\"dt6k9\"}],\"jXnid\":[function(require,module,exports,__globalThis) {\n// src/utils/body.ts\nvar parcelHelpers = require(\"@parcel/transformer-js/src/esmodule-helpers.js\");\nparcelHelpers.defineInteropFlag(exports);\nparcelHelpers.export(exports, \"parseBody\", ()=>parseBody);\nvar _requestJs = require(\"../request.js\");\nvar parseBody = async (request, options = /* @__PURE__ */ Object.create(null))=>{\n    const { all = false, dot = false } = options;\n    const headers = request instanceof (0, _requestJs.HonoRequest) ? request.raw.headers : request.headers;\n    const contentType = headers.get(\"Content-Type\");\n    if (contentType?.startsWith(\"multipart/form-data\") || contentType?.startsWith(\"application/x-www-form-urlencoded\")) return parseFormData(request, {\n        all,\n        dot\n    });\n    return {};\n};\nasync function parseFormData(request, options) {\n    const formData = await request.formData();\n    if (formData) return convertFormDataToBodyData(formData, options);\n    return {};\n}\nfunction convertFormDataToBodyData(formData, options) {\n    const form = /* @__PURE__ */ Object.create(null);\n    formData.forEach((value, key)=>{\n        const shouldParseAllValues = options.all || key.endsWith(\"[]\");\n        if (!shouldParseAllValues) form[key] = value;\n        else handleParsingAllValues(form, key, value);\n    });\n    if (options.dot) Object.entries(form).forEach(([key, value])=>{\n        const shouldParseDotValues = key.includes(\".\");\n        if (shouldParseDotValues) {\n            handleParsingNestedValues(form, key, value);\n            delete form[key];\n        }\n    });\n    return form;\n}\nvar handleParsingAllValues = (form, key, value)=>{\n    if (form[key] !== void 0) {\n        if (Array.isArray(form[key])) form[key].push(value);\n        else form[key] = [\n            form[key],\n            value\n        ];\n    } else form[key] = value;\n};\nvar handleParsingNestedValues = (form, key, value)=>{\n    let nestedForm = form;\n    const keys = key.split(\".\");\n    keys.forEach((key2, index)=>{\n        if (index === keys.length - 1) nestedForm[key2] = value;\n        else {\n            if (!nestedForm[key2] || typeof nestedForm[key2] !== \"object\" || Array.isArray(nestedForm[key2]) || nestedForm[key2] instanceof File) nestedForm[key2] = /* @__PURE__ */ Object.create(null);\n            nestedForm = nestedForm[key2];\n        }\n    });\n};\n\n},{\"../request.js\":\"jXU57\",\"@parcel/transformer-js/src/esmodule-helpers.js\":\"dt6k9\"}],\"lo13I\":[function(require,module,exports,__globalThis) {\n// src/utils/url.ts\nvar parcelHelpers = require(\"@parcel/transformer-js/src/esmodule-helpers.js\");\nparcelHelpers.defineInteropFlag(exports);\nparcelHelpers.export(exports, \"checkOptionalParameter\", ()=>checkOptionalParameter);\nparcelHelpers.export(exports, \"decodeURIComponent_\", ()=>decodeURIComponent_);\nparcelHelpers.export(exports, \"getPath\", ()=>getPath);\nparcelHelpers.export(exports, \"getPathNoStrict\", ()=>getPathNoStrict);\nparcelHelpers.export(exports, \"getPattern\", ()=>getPattern);\nparcelHelpers.export(exports, \"getQueryParam\", ()=>getQueryParam);\nparcelHelpers.export(exports, \"getQueryParams\", ()=>getQueryParams);\nparcelHelpers.export(exports, \"getQueryStrings\", ()=>getQueryStrings);\nparcelHelpers.export(exports, \"mergePath\", ()=>mergePath);\nparcelHelpers.export(exports, \"splitPath\", ()=>splitPath);\nparcelHelpers.export(exports, \"splitRoutingPath\", ()=>splitRoutingPath);\nparcelHelpers.export(exports, \"tryDecode\", ()=>tryDecode);\nvar splitPath = (path)=>{\n    const paths = path.split(\"/\");\n    if (paths[0] === \"\") paths.shift();\n    return paths;\n};\nvar splitRoutingPath = (routePath)=>{\n    const { groups, path } = extractGroupsFromPath(routePath);\n    const paths = splitPath(path);\n    return replaceGroupMarks(paths, groups);\n};\nvar extractGroupsFromPath = (path)=>{\n    const groups = [];\n    path = path.replace(/\\{[^}]+\\}/g, (match, index)=>{\n        const mark = `@${index}`;\n        groups.push([\n            mark,\n            match\n        ]);\n        return mark;\n    });\n    return {\n        groups,\n        path\n    };\n};\nvar replaceGroupMarks = (paths, groups)=>{\n    for(let i = groups.length - 1; i >= 0; i--){\n        const [mark] = groups[i];\n        for(let j = paths.length - 1; j >= 0; j--)if (paths[j].includes(mark)) {\n            paths[j] = paths[j].replace(mark, groups[i][1]);\n            break;\n        }\n    }\n    return paths;\n};\nvar patternCache = {};\nvar getPattern = (label, next)=>{\n    if (label === \"*\") return \"*\";\n    const match = label.match(/^\\:([^\\{\\}]+)(?:\\{(.+)\\})?$/);\n    if (match) {\n        const cacheKey = `${label}#${next}`;\n        if (!patternCache[cacheKey]) {\n            if (match[2]) patternCache[cacheKey] = next && next[0] !== \":\" && next[0] !== \"*\" ? [\n                cacheKey,\n                match[1],\n                new RegExp(`^${match[2]}(?=/${next})`)\n            ] : [\n                label,\n                match[1],\n                new RegExp(`^${match[2]}$`)\n            ];\n            else patternCache[cacheKey] = [\n                label,\n                match[1],\n                true\n            ];\n        }\n        return patternCache[cacheKey];\n    }\n    return null;\n};\nvar tryDecode = (str, decoder)=>{\n    try {\n        return decoder(str);\n    } catch  {\n        return str.replace(/(?:%[0-9A-Fa-f]{2})+/g, (match)=>{\n            try {\n                return decoder(match);\n            } catch  {\n                return match;\n            }\n        });\n    }\n};\nvar tryDecodeURI = (str)=>tryDecode(str, decodeURI);\nvar getPath = (request)=>{\n    const url = request.url;\n    const start = url.indexOf(\"/\", 8);\n    let i = start;\n    for(; i < url.length; i++){\n        const charCode = url.charCodeAt(i);\n        if (charCode === 37) {\n            const queryIndex = url.indexOf(\"?\", i);\n            const path = url.slice(start, queryIndex === -1 ? void 0 : queryIndex);\n            return tryDecodeURI(path.includes(\"%25\") ? path.replace(/%25/g, \"%2525\") : path);\n        } else if (charCode === 63) break;\n    }\n    return url.slice(start, i);\n};\nvar getQueryStrings = (url)=>{\n    const queryIndex = url.indexOf(\"?\", 8);\n    return queryIndex === -1 ? \"\" : \"?\" + url.slice(queryIndex + 1);\n};\nvar getPathNoStrict = (request)=>{\n    const result = getPath(request);\n    return result.length > 1 && result.at(-1) === \"/\" ? result.slice(0, -1) : result;\n};\nvar mergePath = (base, sub, ...rest)=>{\n    if (rest.length) sub = mergePath(sub, ...rest);\n    return `${base?.[0] === \"/\" ? \"\" : \"/\"}${base}${sub === \"/\" ? \"\" : `${base?.at(-1) === \"/\" ? \"\" : \"/\"}${sub?.[0] === \"/\" ? sub.slice(1) : sub}`}`;\n};\nvar checkOptionalParameter = (path)=>{\n    if (path.charCodeAt(path.length - 1) !== 63 || !path.includes(\":\")) return null;\n    const segments = path.split(\"/\");\n    const results = [];\n    let basePath = \"\";\n    segments.forEach((segment)=>{\n        if (segment !== \"\" && !/\\:/.test(segment)) basePath += \"/\" + segment;\n        else if (/\\:/.test(segment)) {\n            if (/\\?/.test(segment)) {\n                if (results.length === 0 && basePath === \"\") results.push(\"/\");\n                else results.push(basePath);\n                const optionalSegment = segment.replace(\"?\", \"\");\n                basePath += \"/\" + optionalSegment;\n                results.push(basePath);\n            } else basePath += \"/\" + segment;\n        }\n    });\n    return results.filter((v, i, a)=>a.indexOf(v) === i);\n};\nvar _decodeURI = (value)=>{\n    if (!/[%+]/.test(value)) return value;\n    if (value.indexOf(\"+\") !== -1) value = value.replace(/\\+/g, \" \");\n    return value.indexOf(\"%\") !== -1 ? decodeURIComponent_(value) : value;\n};\nvar _getQueryParam = (url, key, multiple)=>{\n    let encoded;\n    if (!multiple && key && !/[%+]/.test(key)) {\n        let keyIndex2 = url.indexOf(`?${key}`, 8);\n        if (keyIndex2 === -1) keyIndex2 = url.indexOf(`&${key}`, 8);\n        while(keyIndex2 !== -1){\n            const trailingKeyCode = url.charCodeAt(keyIndex2 + key.length + 1);\n            if (trailingKeyCode === 61) {\n                const valueIndex = keyIndex2 + key.length + 2;\n                const endIndex = url.indexOf(\"&\", valueIndex);\n                return _decodeURI(url.slice(valueIndex, endIndex === -1 ? void 0 : endIndex));\n            } else if (trailingKeyCode == 38 || isNaN(trailingKeyCode)) return \"\";\n            keyIndex2 = url.indexOf(`&${key}`, keyIndex2 + 1);\n        }\n        encoded = /[%+]/.test(url);\n        if (!encoded) return void 0;\n    }\n    const results = {};\n    encoded ??= /[%+]/.test(url);\n    let keyIndex = url.indexOf(\"?\", 8);\n    while(keyIndex !== -1){\n        const nextKeyIndex = url.indexOf(\"&\", keyIndex + 1);\n        let valueIndex = url.indexOf(\"=\", keyIndex);\n        if (valueIndex > nextKeyIndex && nextKeyIndex !== -1) valueIndex = -1;\n        let name = url.slice(keyIndex + 1, valueIndex === -1 ? nextKeyIndex === -1 ? void 0 : nextKeyIndex : valueIndex);\n        if (encoded) name = _decodeURI(name);\n        keyIndex = nextKeyIndex;\n        if (name === \"\") continue;\n        let value;\n        if (valueIndex === -1) value = \"\";\n        else {\n            value = url.slice(valueIndex + 1, nextKeyIndex === -1 ? void 0 : nextKeyIndex);\n            if (encoded) value = _decodeURI(value);\n        }\n        if (multiple) {\n            if (!(results[name] && Array.isArray(results[name]))) results[name] = [];\n            results[name].push(value);\n        } else results[name] ??= value;\n    }\n    return key ? results[key] : results;\n};\nvar getQueryParam = _getQueryParam;\nvar getQueryParams = (url, key)=>{\n    return _getQueryParam(url, key, true);\n};\nvar decodeURIComponent_ = decodeURIComponent;\n\n},{\"@parcel/transformer-js/src/esmodule-helpers.js\":\"dt6k9\"}],\"dRgLc\":[function(require,module,exports,__globalThis) {\n// src/utils/html.ts\nvar parcelHelpers = require(\"@parcel/transformer-js/src/esmodule-helpers.js\");\nparcelHelpers.defineInteropFlag(exports);\nparcelHelpers.export(exports, \"HtmlEscapedCallbackPhase\", ()=>HtmlEscapedCallbackPhase);\nparcelHelpers.export(exports, \"escapeToBuffer\", ()=>escapeToBuffer);\nparcelHelpers.export(exports, \"raw\", ()=>raw);\nparcelHelpers.export(exports, \"resolveCallback\", ()=>resolveCallback);\nparcelHelpers.export(exports, \"resolveCallbackSync\", ()=>resolveCallbackSync);\nparcelHelpers.export(exports, \"stringBufferToString\", ()=>stringBufferToString);\nvar HtmlEscapedCallbackPhase = {\n    Stringify: 1,\n    BeforeStream: 2,\n    Stream: 3\n};\nvar raw = (value, callbacks)=>{\n    const escapedString = new String(value);\n    escapedString.isEscaped = true;\n    escapedString.callbacks = callbacks;\n    return escapedString;\n};\nvar escapeRe = /[&<>'\"]/;\nvar stringBufferToString = async (buffer, callbacks)=>{\n    let str = \"\";\n    callbacks ||= [];\n    const resolvedBuffer = await Promise.all(buffer);\n    for(let i = resolvedBuffer.length - 1;; i--){\n        str += resolvedBuffer[i];\n        i--;\n        if (i < 0) break;\n        let r = resolvedBuffer[i];\n        if (typeof r === \"object\") callbacks.push(...r.callbacks || []);\n        const isEscaped = r.isEscaped;\n        r = await (typeof r === \"object\" ? r.toString() : r);\n        if (typeof r === \"object\") callbacks.push(...r.callbacks || []);\n        if (r.isEscaped ?? isEscaped) str += r;\n        else {\n            const buf = [\n                str\n            ];\n            escapeToBuffer(r, buf);\n            str = buf[0];\n        }\n    }\n    return raw(str, callbacks);\n};\nvar escapeToBuffer = (str, buffer)=>{\n    const match = str.search(escapeRe);\n    if (match === -1) {\n        buffer[0] += str;\n        return;\n    }\n    let escape;\n    let index;\n    let lastIndex = 0;\n    for(index = match; index < str.length; index++){\n        switch(str.charCodeAt(index)){\n            case 34:\n                escape = \"&quot;\";\n                break;\n            case 39:\n                escape = \"&#39;\";\n                break;\n            case 38:\n                escape = \"&amp;\";\n                break;\n            case 60:\n                escape = \"&lt;\";\n                break;\n            case 62:\n                escape = \"&gt;\";\n                break;\n            default:\n                continue;\n        }\n        buffer[0] += str.substring(lastIndex, index) + escape;\n        lastIndex = index + 1;\n    }\n    buffer[0] += str.substring(lastIndex, index);\n};\nvar resolveCallbackSync = (str)=>{\n    const callbacks = str.callbacks;\n    if (!callbacks?.length) return str;\n    const buffer = [\n        str\n    ];\n    const context = {};\n    callbacks.forEach((c)=>c({\n            phase: HtmlEscapedCallbackPhase.Stringify,\n            buffer,\n            context\n        }));\n    return buffer[0];\n};\nvar resolveCallback = async (str, phase, preserveCallbacks, context, buffer)=>{\n    if (typeof str === \"object\" && !(str instanceof String)) {\n        if (!(str instanceof Promise)) str = str.toString();\n        if (str instanceof Promise) str = await str;\n    }\n    const callbacks = str.callbacks;\n    if (!callbacks?.length) return Promise.resolve(str);\n    if (buffer) buffer[0] += str;\n    else buffer = [\n        str\n    ];\n    const resStr = Promise.all(callbacks.map((c)=>c({\n            phase,\n            buffer,\n            context\n        }))).then((res)=>Promise.all(res.filter(Boolean).map((str2)=>resolveCallback(str2, phase, false, context, buffer))).then(()=>buffer[0]));\n    if (preserveCallbacks) return raw(await resStr, callbacks);\n    else return resStr;\n};\n\n},{\"@parcel/transformer-js/src/esmodule-helpers.js\":\"dt6k9\"}],\"2P7Cv\":[function(require,module,exports,__globalThis) {\n// src/router.ts\nvar parcelHelpers = require(\"@parcel/transformer-js/src/esmodule-helpers.js\");\nparcelHelpers.defineInteropFlag(exports);\nparcelHelpers.export(exports, \"MESSAGE_MATCHER_IS_ALREADY_BUILT\", ()=>MESSAGE_MATCHER_IS_ALREADY_BUILT);\nparcelHelpers.export(exports, \"METHODS\", ()=>METHODS);\nparcelHelpers.export(exports, \"METHOD_NAME_ALL\", ()=>METHOD_NAME_ALL);\nparcelHelpers.export(exports, \"METHOD_NAME_ALL_LOWERCASE\", ()=>METHOD_NAME_ALL_LOWERCASE);\nparcelHelpers.export(exports, \"UnsupportedPathError\", ()=>UnsupportedPathError);\nvar METHOD_NAME_ALL = \"ALL\";\nvar METHOD_NAME_ALL_LOWERCASE = \"all\";\nvar METHODS = [\n    \"get\",\n    \"post\",\n    \"put\",\n    \"delete\",\n    \"options\",\n    \"patch\"\n];\nvar MESSAGE_MATCHER_IS_ALREADY_BUILT = \"Can not add a route since the matcher is already built.\";\nvar UnsupportedPathError = class extends Error {\n};\n\n},{\"@parcel/transformer-js/src/esmodule-helpers.js\":\"dt6k9\"}],\"htJPb\":[function(require,module,exports,__globalThis) {\n// src/utils/constants.ts\nvar parcelHelpers = require(\"@parcel/transformer-js/src/esmodule-helpers.js\");\nparcelHelpers.defineInteropFlag(exports);\nparcelHelpers.export(exports, \"COMPOSED_HANDLER\", ()=>COMPOSED_HANDLER);\nvar COMPOSED_HANDLER = \"__COMPOSED_HANDLER\";\n\n},{\"@parcel/transformer-js/src/esmodule-helpers.js\":\"dt6k9\"}],\"g63tS\":[function(require,module,exports,__globalThis) {\n// src/router/reg-exp-router/index.ts\nvar parcelHelpers = require(\"@parcel/transformer-js/src/esmodule-helpers.js\");\nparcelHelpers.defineInteropFlag(exports);\nparcelHelpers.export(exports, \"RegExpRouter\", ()=>(0, _routerJs.RegExpRouter));\nvar _routerJs = require(\"./router.js\");\n\n},{\"./router.js\":\"eTSHg\",\"@parcel/transformer-js/src/esmodule-helpers.js\":\"dt6k9\"}],\"eTSHg\":[function(require,module,exports,__globalThis) {\n// src/router/reg-exp-router/router.ts\nvar parcelHelpers = require(\"@parcel/transformer-js/src/esmodule-helpers.js\");\nparcelHelpers.defineInteropFlag(exports);\nparcelHelpers.export(exports, \"RegExpRouter\", ()=>RegExpRouter);\nvar _routerJs = require(\"../../router.js\");\nvar _urlJs = require(\"../../utils/url.js\");\nvar _nodeJs = require(\"./node.js\");\nvar _trieJs = require(\"./trie.js\");\nvar emptyParam = [];\nvar nullMatcher = [\n    /^$/,\n    [],\n    /* @__PURE__ */ Object.create(null)\n];\nvar wildcardRegExpCache = /* @__PURE__ */ Object.create(null);\nfunction buildWildcardRegExp(path) {\n    return wildcardRegExpCache[path] ??= new RegExp(path === \"*\" ? \"\" : `^${path.replace(/\\/\\*$|([.\\\\+*[^\\]$()])/g, (_, metaChar)=>metaChar ? `\\\\${metaChar}` : \"(?:|/.*)\")}$`);\n}\nfunction clearWildcardRegExpCache() {\n    wildcardRegExpCache = /* @__PURE__ */ Object.create(null);\n}\nfunction buildMatcherFromPreprocessedRoutes(routes) {\n    const trie = new (0, _trieJs.Trie)();\n    const handlerData = [];\n    if (routes.length === 0) return nullMatcher;\n    const routesWithStaticPathFlag = routes.map((route)=>[\n            !/\\*|\\/:/.test(route[0]),\n            ...route\n        ]).sort(([isStaticA, pathA], [isStaticB, pathB])=>isStaticA ? 1 : isStaticB ? -1 : pathA.length - pathB.length);\n    const staticMap = /* @__PURE__ */ Object.create(null);\n    for(let i = 0, j = -1, len = routesWithStaticPathFlag.length; i < len; i++){\n        const [pathErrorCheckOnly, path, handlers] = routesWithStaticPathFlag[i];\n        if (pathErrorCheckOnly) staticMap[path] = [\n            handlers.map(([h])=>[\n                    h,\n                    /* @__PURE__ */ Object.create(null)\n                ]),\n            emptyParam\n        ];\n        else j++;\n        let paramAssoc;\n        try {\n            paramAssoc = trie.insert(path, j, pathErrorCheckOnly);\n        } catch (e) {\n            throw e === (0, _nodeJs.PATH_ERROR) ? new (0, _routerJs.UnsupportedPathError)(path) : e;\n        }\n        if (pathErrorCheckOnly) continue;\n        handlerData[j] = handlers.map(([h, paramCount])=>{\n            const paramIndexMap = /* @__PURE__ */ Object.create(null);\n            paramCount -= 1;\n            for(; paramCount >= 0; paramCount--){\n                const [key, value] = paramAssoc[paramCount];\n                paramIndexMap[key] = value;\n            }\n            return [\n                h,\n                paramIndexMap\n            ];\n        });\n    }\n    const [regexp, indexReplacementMap, paramReplacementMap] = trie.buildRegExp();\n    for(let i = 0, len = handlerData.length; i < len; i++)for(let j = 0, len2 = handlerData[i].length; j < len2; j++){\n        const map = handlerData[i][j]?.[1];\n        if (!map) continue;\n        const keys = Object.keys(map);\n        for(let k = 0, len3 = keys.length; k < len3; k++)map[keys[k]] = paramReplacementMap[map[keys[k]]];\n    }\n    const handlerMap = [];\n    for(const i in indexReplacementMap)handlerMap[i] = handlerData[indexReplacementMap[i]];\n    return [\n        regexp,\n        handlerMap,\n        staticMap\n    ];\n}\nfunction findMiddleware(middleware, path) {\n    if (!middleware) return void 0;\n    for (const k of Object.keys(middleware).sort((a, b)=>b.length - a.length)){\n        if (buildWildcardRegExp(k).test(path)) return [\n            ...middleware[k]\n        ];\n    }\n    return void 0;\n}\nvar RegExpRouter = class {\n    name = \"RegExpRouter\";\n    #middleware;\n    #routes;\n    constructor(){\n        this.#middleware = {\n            [(0, _routerJs.METHOD_NAME_ALL)]: /* @__PURE__ */ Object.create(null)\n        };\n        this.#routes = {\n            [(0, _routerJs.METHOD_NAME_ALL)]: /* @__PURE__ */ Object.create(null)\n        };\n    }\n    add(method, path, handler) {\n        const middleware = this.#middleware;\n        const routes = this.#routes;\n        if (!middleware || !routes) throw new Error((0, _routerJs.MESSAGE_MATCHER_IS_ALREADY_BUILT));\n        if (!middleware[method]) [\n            middleware,\n            routes\n        ].forEach((handlerMap)=>{\n            handlerMap[method] = /* @__PURE__ */ Object.create(null);\n            Object.keys(handlerMap[0, _routerJs.METHOD_NAME_ALL]).forEach((p)=>{\n                handlerMap[method][p] = [\n                    ...handlerMap[0, _routerJs.METHOD_NAME_ALL][p]\n                ];\n            });\n        });\n        if (path === \"/*\") path = \"*\";\n        const paramCount = (path.match(/\\/:/g) || []).length;\n        if (/\\*$/.test(path)) {\n            const re = buildWildcardRegExp(path);\n            if (method === (0, _routerJs.METHOD_NAME_ALL)) Object.keys(middleware).forEach((m)=>{\n                middleware[m][path] ||= findMiddleware(middleware[m], path) || findMiddleware(middleware[0, _routerJs.METHOD_NAME_ALL], path) || [];\n            });\n            else middleware[method][path] ||= findMiddleware(middleware[method], path) || findMiddleware(middleware[0, _routerJs.METHOD_NAME_ALL], path) || [];\n            Object.keys(middleware).forEach((m)=>{\n                if (method === (0, _routerJs.METHOD_NAME_ALL) || method === m) Object.keys(middleware[m]).forEach((p)=>{\n                    re.test(p) && middleware[m][p].push([\n                        handler,\n                        paramCount\n                    ]);\n                });\n            });\n            Object.keys(routes).forEach((m)=>{\n                if (method === (0, _routerJs.METHOD_NAME_ALL) || method === m) Object.keys(routes[m]).forEach((p)=>re.test(p) && routes[m][p].push([\n                        handler,\n                        paramCount\n                    ]));\n            });\n            return;\n        }\n        const paths = (0, _urlJs.checkOptionalParameter)(path) || [\n            path\n        ];\n        for(let i = 0, len = paths.length; i < len; i++){\n            const path2 = paths[i];\n            Object.keys(routes).forEach((m)=>{\n                if (method === (0, _routerJs.METHOD_NAME_ALL) || method === m) {\n                    routes[m][path2] ||= [\n                        ...findMiddleware(middleware[m], path2) || findMiddleware(middleware[0, _routerJs.METHOD_NAME_ALL], path2) || []\n                    ];\n                    routes[m][path2].push([\n                        handler,\n                        paramCount - len + i + 1\n                    ]);\n                }\n            });\n        }\n    }\n    match(method, path) {\n        clearWildcardRegExpCache();\n        const matchers = this.#buildAllMatchers();\n        this.match = (method2, path2)=>{\n            const matcher = matchers[method2] || matchers[0, _routerJs.METHOD_NAME_ALL];\n            const staticMatch = matcher[2][path2];\n            if (staticMatch) return staticMatch;\n            const match = path2.match(matcher[0]);\n            if (!match) return [\n                [],\n                emptyParam\n            ];\n            const index = match.indexOf(\"\", 1);\n            return [\n                matcher[1][index],\n                match\n            ];\n        };\n        return this.match(method, path);\n    }\n    #buildAllMatchers() {\n        const matchers = /* @__PURE__ */ Object.create(null);\n        Object.keys(this.#routes).concat(Object.keys(this.#middleware)).forEach((method)=>{\n            matchers[method] ||= this.#buildMatcher(method);\n        });\n        this.#middleware = this.#routes = void 0;\n        return matchers;\n    }\n    #buildMatcher(method) {\n        const routes = [];\n        let hasOwnRoute = method === (0, _routerJs.METHOD_NAME_ALL);\n        [\n            this.#middleware,\n            this.#routes\n        ].forEach((r)=>{\n            const ownRoute = r[method] ? Object.keys(r[method]).map((path)=>[\n                    path,\n                    r[method][path]\n                ]) : [];\n            if (ownRoute.length !== 0) {\n                hasOwnRoute ||= true;\n                routes.push(...ownRoute);\n            } else if (method !== (0, _routerJs.METHOD_NAME_ALL)) routes.push(...Object.keys(r[0, _routerJs.METHOD_NAME_ALL]).map((path)=>[\n                    path,\n                    r[0, _routerJs.METHOD_NAME_ALL][path]\n                ]));\n        });\n        if (!hasOwnRoute) return null;\n        else return buildMatcherFromPreprocessedRoutes(routes);\n    }\n};\n\n},{\"../../router.js\":\"2P7Cv\",\"../../utils/url.js\":\"lo13I\",\"./node.js\":\"7pXuX\",\"./trie.js\":\"fYg0f\",\"@parcel/transformer-js/src/esmodule-helpers.js\":\"dt6k9\"}],\"7pXuX\":[function(require,module,exports,__globalThis) {\n// src/router/reg-exp-router/node.ts\nvar parcelHelpers = require(\"@parcel/transformer-js/src/esmodule-helpers.js\");\nparcelHelpers.defineInteropFlag(exports);\nparcelHelpers.export(exports, \"Node\", ()=>Node);\nparcelHelpers.export(exports, \"PATH_ERROR\", ()=>PATH_ERROR);\nvar LABEL_REG_EXP_STR = \"[^/]+\";\nvar ONLY_WILDCARD_REG_EXP_STR = \".*\";\nvar TAIL_WILDCARD_REG_EXP_STR = \"(?:|/.*)\";\nvar PATH_ERROR = Symbol();\nvar regExpMetaChars = new Set(\".\\\\+*[^]$()\");\nfunction compareKey(a, b) {\n    if (a.length === 1) return b.length === 1 ? a < b ? -1 : 1 : -1;\n    if (b.length === 1) return 1;\n    if (a === ONLY_WILDCARD_REG_EXP_STR || a === TAIL_WILDCARD_REG_EXP_STR) return 1;\n    else if (b === ONLY_WILDCARD_REG_EXP_STR || b === TAIL_WILDCARD_REG_EXP_STR) return -1;\n    if (a === LABEL_REG_EXP_STR) return 1;\n    else if (b === LABEL_REG_EXP_STR) return -1;\n    return a.length === b.length ? a < b ? -1 : 1 : b.length - a.length;\n}\nvar Node = class {\n    #index;\n    #varIndex;\n    #children = /* @__PURE__ */ Object.create(null);\n    insert(tokens, index, paramMap, context, pathErrorCheckOnly) {\n        if (tokens.length === 0) {\n            if (this.#index !== void 0) throw PATH_ERROR;\n            if (pathErrorCheckOnly) return;\n            this.#index = index;\n            return;\n        }\n        const [token, ...restTokens] = tokens;\n        const pattern = token === \"*\" ? restTokens.length === 0 ? [\n            \"\",\n            \"\",\n            ONLY_WILDCARD_REG_EXP_STR\n        ] : [\n            \"\",\n            \"\",\n            LABEL_REG_EXP_STR\n        ] : token === \"/*\" ? [\n            \"\",\n            \"\",\n            TAIL_WILDCARD_REG_EXP_STR\n        ] : token.match(/^\\:([^\\{\\}]+)(?:\\{(.+)\\})?$/);\n        let node;\n        if (pattern) {\n            const name = pattern[1];\n            let regexpStr = pattern[2] || LABEL_REG_EXP_STR;\n            if (name && pattern[2]) {\n                regexpStr = regexpStr.replace(/^\\((?!\\?:)(?=[^)]+\\)$)/, \"(?:\");\n                if (/\\((?!\\?:)/.test(regexpStr)) throw PATH_ERROR;\n            }\n            node = this.#children[regexpStr];\n            if (!node) {\n                if (Object.keys(this.#children).some((k)=>k !== ONLY_WILDCARD_REG_EXP_STR && k !== TAIL_WILDCARD_REG_EXP_STR)) throw PATH_ERROR;\n                if (pathErrorCheckOnly) return;\n                node = this.#children[regexpStr] = new Node();\n                if (name !== \"\") node.#varIndex = context.varIndex++;\n            }\n            if (!pathErrorCheckOnly && name !== \"\") paramMap.push([\n                name,\n                node.#varIndex\n            ]);\n        } else {\n            node = this.#children[token];\n            if (!node) {\n                if (Object.keys(this.#children).some((k)=>k.length > 1 && k !== ONLY_WILDCARD_REG_EXP_STR && k !== TAIL_WILDCARD_REG_EXP_STR)) throw PATH_ERROR;\n                if (pathErrorCheckOnly) return;\n                node = this.#children[token] = new Node();\n            }\n        }\n        node.insert(restTokens, index, paramMap, context, pathErrorCheckOnly);\n    }\n    buildRegExpStr() {\n        const childKeys = Object.keys(this.#children).sort(compareKey);\n        const strList = childKeys.map((k)=>{\n            const c = this.#children[k];\n            return (typeof c.#varIndex === \"number\" ? `(${k})@${c.#varIndex}` : regExpMetaChars.has(k) ? `\\\\${k}` : k) + c.buildRegExpStr();\n        });\n        if (typeof this.#index === \"number\") strList.unshift(`#${this.#index}`);\n        if (strList.length === 0) return \"\";\n        if (strList.length === 1) return strList[0];\n        return \"(?:\" + strList.join(\"|\") + \")\";\n    }\n};\n\n},{\"@parcel/transformer-js/src/esmodule-helpers.js\":\"dt6k9\"}],\"fYg0f\":[function(require,module,exports,__globalThis) {\n// src/router/reg-exp-router/trie.ts\nvar parcelHelpers = require(\"@parcel/transformer-js/src/esmodule-helpers.js\");\nparcelHelpers.defineInteropFlag(exports);\nparcelHelpers.export(exports, \"Trie\", ()=>Trie);\nvar _nodeJs = require(\"./node.js\");\nvar Trie = class {\n    #context = {\n        varIndex: 0\n    };\n    #root = new (0, _nodeJs.Node)();\n    insert(path, index, pathErrorCheckOnly) {\n        const paramAssoc = [];\n        const groups = [];\n        for(let i = 0;;){\n            let replaced = false;\n            path = path.replace(/\\{[^}]+\\}/g, (m)=>{\n                const mark = `@\\\\${i}`;\n                groups[i] = [\n                    mark,\n                    m\n                ];\n                i++;\n                replaced = true;\n                return mark;\n            });\n            if (!replaced) break;\n        }\n        const tokens = path.match(/(?::[^\\/]+)|(?:\\/\\*$)|./g) || [];\n        for(let i = groups.length - 1; i >= 0; i--){\n            const [mark] = groups[i];\n            for(let j = tokens.length - 1; j >= 0; j--)if (tokens[j].indexOf(mark) !== -1) {\n                tokens[j] = tokens[j].replace(mark, groups[i][1]);\n                break;\n            }\n        }\n        this.#root.insert(tokens, index, paramAssoc, this.#context, pathErrorCheckOnly);\n        return paramAssoc;\n    }\n    buildRegExp() {\n        let regexp = this.#root.buildRegExpStr();\n        if (regexp === \"\") return [\n            /^$/,\n            [],\n            []\n        ];\n        let captureIndex = 0;\n        const indexReplacementMap = [];\n        const paramReplacementMap = [];\n        regexp = regexp.replace(/#(\\d+)|@(\\d+)|\\.\\*\\$/g, (_, handlerIndex, paramIndex)=>{\n            if (handlerIndex !== void 0) {\n                indexReplacementMap[++captureIndex] = Number(handlerIndex);\n                return \"$()\";\n            }\n            if (paramIndex !== void 0) {\n                paramReplacementMap[Number(paramIndex)] = ++captureIndex;\n                return \"\";\n            }\n            return \"\";\n        });\n        return [\n            new RegExp(`^${regexp}`),\n            indexReplacementMap,\n            paramReplacementMap\n        ];\n    }\n};\n\n},{\"./node.js\":\"7pXuX\",\"@parcel/transformer-js/src/esmodule-helpers.js\":\"dt6k9\"}],\"7xsbc\":[function(require,module,exports,__globalThis) {\n// src/router/smart-router/index.ts\nvar parcelHelpers = require(\"@parcel/transformer-js/src/esmodule-helpers.js\");\nparcelHelpers.defineInteropFlag(exports);\nparcelHelpers.export(exports, \"SmartRouter\", ()=>(0, _routerJs.SmartRouter));\nvar _routerJs = require(\"./router.js\");\n\n},{\"./router.js\":\"b28IK\",\"@parcel/transformer-js/src/esmodule-helpers.js\":\"dt6k9\"}],\"b28IK\":[function(require,module,exports,__globalThis) {\n// src/router/smart-router/router.ts\nvar parcelHelpers = require(\"@parcel/transformer-js/src/esmodule-helpers.js\");\nparcelHelpers.defineInteropFlag(exports);\nparcelHelpers.export(exports, \"SmartRouter\", ()=>SmartRouter);\nvar _routerJs = require(\"../../router.js\");\nvar SmartRouter = class {\n    name = \"SmartRouter\";\n    #routers = [];\n    #routes = [];\n    constructor(init){\n        this.#routers = init.routers;\n    }\n    add(method, path, handler) {\n        if (!this.#routes) throw new Error((0, _routerJs.MESSAGE_MATCHER_IS_ALREADY_BUILT));\n        this.#routes.push([\n            method,\n            path,\n            handler\n        ]);\n    }\n    match(method, path) {\n        if (!this.#routes) throw new Error(\"Fatal error\");\n        const routers = this.#routers;\n        const routes = this.#routes;\n        const len = routers.length;\n        let i = 0;\n        let res;\n        for(; i < len; i++){\n            const router = routers[i];\n            try {\n                for(let i2 = 0, len2 = routes.length; i2 < len2; i2++)router.add(...routes[i2]);\n                res = router.match(method, path);\n            } catch (e) {\n                if (e instanceof (0, _routerJs.UnsupportedPathError)) continue;\n                throw e;\n            }\n            this.match = router.match.bind(router);\n            this.#routers = [\n                router\n            ];\n            this.#routes = void 0;\n            break;\n        }\n        if (i === len) throw new Error(\"Fatal error\");\n        this.name = `SmartRouter + ${this.activeRouter.name}`;\n        return res;\n    }\n    get activeRouter() {\n        if (this.#routes || this.#routers.length !== 1) throw new Error(\"No active router has been determined yet.\");\n        return this.#routers[0];\n    }\n};\n\n},{\"../../router.js\":\"2P7Cv\",\"@parcel/transformer-js/src/esmodule-helpers.js\":\"dt6k9\"}],\"3vG3W\":[function(require,module,exports,__globalThis) {\n// src/router/trie-router/index.ts\nvar parcelHelpers = require(\"@parcel/transformer-js/src/esmodule-helpers.js\");\nparcelHelpers.defineInteropFlag(exports);\nparcelHelpers.export(exports, \"TrieRouter\", ()=>(0, _routerJs.TrieRouter));\nvar _routerJs = require(\"./router.js\");\n\n},{\"./router.js\":\"9qF44\",\"@parcel/transformer-js/src/esmodule-helpers.js\":\"dt6k9\"}],\"9qF44\":[function(require,module,exports,__globalThis) {\n// src/router/trie-router/router.ts\nvar parcelHelpers = require(\"@parcel/transformer-js/src/esmodule-helpers.js\");\nparcelHelpers.defineInteropFlag(exports);\nparcelHelpers.export(exports, \"TrieRouter\", ()=>TrieRouter);\nvar _urlJs = require(\"../../utils/url.js\");\nvar _nodeJs = require(\"./node.js\");\nvar TrieRouter = class {\n    name = \"TrieRouter\";\n    #node;\n    constructor(){\n        this.#node = new (0, _nodeJs.Node)();\n    }\n    add(method, path, handler) {\n        const results = (0, _urlJs.checkOptionalParameter)(path);\n        if (results) {\n            for(let i = 0, len = results.length; i < len; i++)this.#node.insert(method, results[i], handler);\n            return;\n        }\n        this.#node.insert(method, path, handler);\n    }\n    match(method, path) {\n        return this.#node.search(method, path);\n    }\n};\n\n},{\"../../utils/url.js\":\"lo13I\",\"./node.js\":\"21HVx\",\"@parcel/transformer-js/src/esmodule-helpers.js\":\"dt6k9\"}],\"21HVx\":[function(require,module,exports,__globalThis) {\n// src/router/trie-router/node.ts\nvar parcelHelpers = require(\"@parcel/transformer-js/src/esmodule-helpers.js\");\nparcelHelpers.defineInteropFlag(exports);\nparcelHelpers.export(exports, \"Node\", ()=>Node);\nvar _routerJs = require(\"../../router.js\");\nvar _urlJs = require(\"../../utils/url.js\");\nvar emptyParams = /* @__PURE__ */ Object.create(null);\nvar Node = class {\n    #methods;\n    #children;\n    #patterns;\n    #order = 0;\n    #params = emptyParams;\n    constructor(method, handler, children){\n        this.#children = children || /* @__PURE__ */ Object.create(null);\n        this.#methods = [];\n        if (method && handler) {\n            const m = /* @__PURE__ */ Object.create(null);\n            m[method] = {\n                handler,\n                possibleKeys: [],\n                score: 0\n            };\n            this.#methods = [\n                m\n            ];\n        }\n        this.#patterns = [];\n    }\n    insert(method, path, handler) {\n        this.#order = ++this.#order;\n        let curNode = this;\n        const parts = (0, _urlJs.splitRoutingPath)(path);\n        const possibleKeys = [];\n        for(let i = 0, len = parts.length; i < len; i++){\n            const p = parts[i];\n            const nextP = parts[i + 1];\n            const pattern = (0, _urlJs.getPattern)(p, nextP);\n            const key = Array.isArray(pattern) ? pattern[0] : p;\n            if (Object.keys(curNode.#children).includes(key)) {\n                curNode = curNode.#children[key];\n                const pattern2 = (0, _urlJs.getPattern)(p, nextP);\n                if (pattern2) possibleKeys.push(pattern2[1]);\n                continue;\n            }\n            curNode.#children[key] = new Node();\n            if (pattern) {\n                curNode.#patterns.push(pattern);\n                possibleKeys.push(pattern[1]);\n            }\n            curNode = curNode.#children[key];\n        }\n        const m = /* @__PURE__ */ Object.create(null);\n        const handlerSet = {\n            handler,\n            possibleKeys: possibleKeys.filter((v, i, a)=>a.indexOf(v) === i),\n            score: this.#order\n        };\n        m[method] = handlerSet;\n        curNode.#methods.push(m);\n        return curNode;\n    }\n    #getHandlerSets(node, method, nodeParams, params) {\n        const handlerSets = [];\n        for(let i = 0, len = node.#methods.length; i < len; i++){\n            const m = node.#methods[i];\n            const handlerSet = m[method] || m[0, _routerJs.METHOD_NAME_ALL];\n            const processedSet = {};\n            if (handlerSet !== void 0) {\n                handlerSet.params = /* @__PURE__ */ Object.create(null);\n                handlerSets.push(handlerSet);\n                if (nodeParams !== emptyParams || params && params !== emptyParams) for(let i2 = 0, len2 = handlerSet.possibleKeys.length; i2 < len2; i2++){\n                    const key = handlerSet.possibleKeys[i2];\n                    const processed = processedSet[handlerSet.score];\n                    handlerSet.params[key] = params?.[key] && !processed ? params[key] : nodeParams[key] ?? params?.[key];\n                    processedSet[handlerSet.score] = true;\n                }\n            }\n        }\n        return handlerSets;\n    }\n    search(method, path) {\n        const handlerSets = [];\n        this.#params = emptyParams;\n        const curNode = this;\n        let curNodes = [\n            curNode\n        ];\n        const parts = (0, _urlJs.splitPath)(path);\n        const curNodesQueue = [];\n        for(let i = 0, len = parts.length; i < len; i++){\n            const part = parts[i];\n            const isLast = i === len - 1;\n            const tempNodes = [];\n            for(let j = 0, len2 = curNodes.length; j < len2; j++){\n                const node = curNodes[j];\n                const nextNode = node.#children[part];\n                if (nextNode) {\n                    nextNode.#params = node.#params;\n                    if (isLast) {\n                        if (nextNode.#children[\"*\"]) handlerSets.push(...this.#getHandlerSets(nextNode.#children[\"*\"], method, node.#params));\n                        handlerSets.push(...this.#getHandlerSets(nextNode, method, node.#params));\n                    } else tempNodes.push(nextNode);\n                }\n                for(let k = 0, len3 = node.#patterns.length; k < len3; k++){\n                    const pattern = node.#patterns[k];\n                    const params = node.#params === emptyParams ? {} : {\n                        ...node.#params\n                    };\n                    if (pattern === \"*\") {\n                        const astNode = node.#children[\"*\"];\n                        if (astNode) {\n                            handlerSets.push(...this.#getHandlerSets(astNode, method, node.#params));\n                            astNode.#params = params;\n                            tempNodes.push(astNode);\n                        }\n                        continue;\n                    }\n                    if (part === \"\") continue;\n                    const [key, name, matcher] = pattern;\n                    const child = node.#children[key];\n                    const restPathString = parts.slice(i).join(\"/\");\n                    if (matcher instanceof RegExp) {\n                        const m = matcher.exec(restPathString);\n                        if (m) {\n                            params[name] = m[0];\n                            handlerSets.push(...this.#getHandlerSets(child, method, node.#params, params));\n                            if (Object.keys(child.#children).length) {\n                                child.#params = params;\n                                const componentCount = m[0].match(/\\//)?.length ?? 0;\n                                const targetCurNodes = curNodesQueue[componentCount] ||= [];\n                                targetCurNodes.push(child);\n                            }\n                            continue;\n                        }\n                    }\n                    if (matcher === true || matcher.test(part)) {\n                        params[name] = part;\n                        if (isLast) {\n                            handlerSets.push(...this.#getHandlerSets(child, method, params, node.#params));\n                            if (child.#children[\"*\"]) handlerSets.push(...this.#getHandlerSets(child.#children[\"*\"], method, params, node.#params));\n                        } else {\n                            child.#params = params;\n                            tempNodes.push(child);\n                        }\n                    }\n                }\n            }\n            curNodes = tempNodes.concat(curNodesQueue.shift() ?? []);\n        }\n        if (handlerSets.length > 1) handlerSets.sort((a, b)=>{\n            return a.score - b.score;\n        });\n        return [\n            handlerSets.map(({ handler, params })=>[\n                    handler,\n                    params\n                ])\n        ];\n    }\n};\n\n},{\"../../router.js\":\"2P7Cv\",\"../../utils/url.js\":\"lo13I\",\"@parcel/transformer-js/src/esmodule-helpers.js\":\"dt6k9\"}],\"6Gli9\":[function(require,module,exports,__globalThis) {\nvar parcelHelpers = require(\"@parcel/transformer-js/src/esmodule-helpers.js\");\nparcelHelpers.defineInteropFlag(exports);\nparcelHelpers.export(exports, \"FOO\", ()=>FOO);\nconst FOO = 'BAR';\n\n},{\"@parcel/transformer-js/src/esmodule-helpers.js\":\"dt6k9\"}]},[\"dDS2A\"], \"dDS2A\", \"parcelRequire375b\", {})\nlet {default: _default, } = parcelRequire375b(\"dDS2A\");\nexport {_default as default, };\n\n//# sourceMappingURL=index.js.map\n","//import { dumpanyprettified } from '@offirmo-private/prettify-any'\n\nimport { Hono } from 'hono'\n\n//import { type Bindings } from './types.ts'\nimport { FOO } from './endpoints/users/index.ts'\n\n/////////////////////////////////////////////////\n\nconst app = new Hono()\n\n/////////////////////////////////////////////////\n\napp.onError((err, c) => {\n\tconsole.error(`${err}`)\n\n\treturn c.text('Error from Hono', 500)\n})\n\n/////////////////////////////////////////////////\n\napp.notFound((c) => {\n\tconsole.log(`Hono notFound`, c.req.url)\n\t//debugger\n\n\t//return c.text('404 from Hono!', 404)\n\n\tconst url404 = new URL('404.html', c.req.url)\n\treturn c.env.ASSETS.fetch(url404)\n})\n\n/////////////////////////////////////////////////\n\napp.use(async (c, next) => {\n\tconsole.log(`Hono before`, c.req.url)\n\tawait next()\n\tconsole.log(`Hono after`, c.req.url)\n})\n\napp.get('/api', (c) => c.text(`Hello Cloudflare Workers! ${FOO}`))\napp.get('/test', (c) => c.text('Hono!'))\n\n/*\napp.all('*', c => {\n\tconsole.log(`Hono All`, c.req.url)\n\n\t// https://developers.cloudflare.com/workers/static-assets/binding/#runtime-api-reference\n\t//return c.env.ASSETS.fetch(c.req.raw);\n})*/\n\nexport default app\n","// src/index.ts\nimport { Hono } from \"./hono.js\";\nexport {\n  Hono\n};\n","// src/hono.ts\nimport { HonoBase } from \"./hono-base.js\";\nimport { RegExpRouter } from \"./router/reg-exp-router/index.js\";\nimport { SmartRouter } from \"./router/smart-router/index.js\";\nimport { TrieRouter } from \"./router/trie-router/index.js\";\nvar Hono = class extends HonoBase {\n  constructor(options = {}) {\n    super(options);\n    this.router = options.router ?? new SmartRouter({\n      routers: [new RegExpRouter(), new TrieRouter()]\n    });\n  }\n};\nexport {\n  Hono\n};\n","// src/hono-base.ts\nimport { compose } from \"./compose.js\";\nimport { Context } from \"./context.js\";\nimport { METHODS, METHOD_NAME_ALL, METHOD_NAME_ALL_LOWERCASE } from \"./router.js\";\nimport { COMPOSED_HANDLER } from \"./utils/constants.js\";\nimport { getPath, getPathNoStrict, mergePath } from \"./utils/url.js\";\nvar notFoundHandler = (c) => {\n  return c.text(\"404 Not Found\", 404);\n};\nvar errorHandler = (err, c) => {\n  if (\"getResponse\" in err) {\n    const res = err.getResponse();\n    return c.newResponse(res.body, res);\n  }\n  console.error(err);\n  return c.text(\"Internal Server Error\", 500);\n};\nvar Hono = class {\n  get;\n  post;\n  put;\n  delete;\n  options;\n  patch;\n  all;\n  on;\n  use;\n  router;\n  getPath;\n  _basePath = \"/\";\n  #path = \"/\";\n  routes = [];\n  constructor(options = {}) {\n    const allMethods = [...METHODS, METHOD_NAME_ALL_LOWERCASE];\n    allMethods.forEach((method) => {\n      this[method] = (args1, ...args) => {\n        if (typeof args1 === \"string\") {\n          this.#path = args1;\n        } else {\n          this.#addRoute(method, this.#path, args1);\n        }\n        args.forEach((handler) => {\n          this.#addRoute(method, this.#path, handler);\n        });\n        return this;\n      };\n    });\n    this.on = (method, path, ...handlers) => {\n      for (const p of [path].flat()) {\n        this.#path = p;\n        for (const m of [method].flat()) {\n          handlers.map((handler) => {\n            this.#addRoute(m.toUpperCase(), this.#path, handler);\n          });\n        }\n      }\n      return this;\n    };\n    this.use = (arg1, ...handlers) => {\n      if (typeof arg1 === \"string\") {\n        this.#path = arg1;\n      } else {\n        this.#path = \"*\";\n        handlers.unshift(arg1);\n      }\n      handlers.forEach((handler) => {\n        this.#addRoute(METHOD_NAME_ALL, this.#path, handler);\n      });\n      return this;\n    };\n    const { strict, ...optionsWithoutStrict } = options;\n    Object.assign(this, optionsWithoutStrict);\n    this.getPath = strict ?? true ? options.getPath ?? getPath : getPathNoStrict;\n  }\n  #clone() {\n    const clone = new Hono({\n      router: this.router,\n      getPath: this.getPath\n    });\n    clone.errorHandler = this.errorHandler;\n    clone.#notFoundHandler = this.#notFoundHandler;\n    clone.routes = this.routes;\n    return clone;\n  }\n  #notFoundHandler = notFoundHandler;\n  errorHandler = errorHandler;\n  route(path, app) {\n    const subApp = this.basePath(path);\n    app.routes.map((r) => {\n      let handler;\n      if (app.errorHandler === errorHandler) {\n        handler = r.handler;\n      } else {\n        handler = async (c, next) => (await compose([], app.errorHandler)(c, () => r.handler(c, next))).res;\n        handler[COMPOSED_HANDLER] = r.handler;\n      }\n      subApp.#addRoute(r.method, r.path, handler);\n    });\n    return this;\n  }\n  basePath(path) {\n    const subApp = this.#clone();\n    subApp._basePath = mergePath(this._basePath, path);\n    return subApp;\n  }\n  onError = (handler) => {\n    this.errorHandler = handler;\n    return this;\n  };\n  notFound = (handler) => {\n    this.#notFoundHandler = handler;\n    return this;\n  };\n  mount(path, applicationHandler, options) {\n    let replaceRequest;\n    let optionHandler;\n    if (options) {\n      if (typeof options === \"function\") {\n        optionHandler = options;\n      } else {\n        optionHandler = options.optionHandler;\n        if (options.replaceRequest === false) {\n          replaceRequest = (request) => request;\n        } else {\n          replaceRequest = options.replaceRequest;\n        }\n      }\n    }\n    const getOptions = optionHandler ? (c) => {\n      const options2 = optionHandler(c);\n      return Array.isArray(options2) ? options2 : [options2];\n    } : (c) => {\n      let executionContext = void 0;\n      try {\n        executionContext = c.executionCtx;\n      } catch {\n      }\n      return [c.env, executionContext];\n    };\n    replaceRequest ||= (() => {\n      const mergedPath = mergePath(this._basePath, path);\n      const pathPrefixLength = mergedPath === \"/\" ? 0 : mergedPath.length;\n      return (request) => {\n        const url = new URL(request.url);\n        url.pathname = url.pathname.slice(pathPrefixLength) || \"/\";\n        return new Request(url, request);\n      };\n    })();\n    const handler = async (c, next) => {\n      const res = await applicationHandler(replaceRequest(c.req.raw), ...getOptions(c));\n      if (res) {\n        return res;\n      }\n      await next();\n    };\n    this.#addRoute(METHOD_NAME_ALL, mergePath(path, \"*\"), handler);\n    return this;\n  }\n  #addRoute(method, path, handler) {\n    method = method.toUpperCase();\n    path = mergePath(this._basePath, path);\n    const r = { path, method, handler };\n    this.router.add(method, path, [handler, r]);\n    this.routes.push(r);\n  }\n  #handleError(err, c) {\n    if (err instanceof Error) {\n      return this.errorHandler(err, c);\n    }\n    throw err;\n  }\n  #dispatch(request, executionCtx, env, method) {\n    if (method === \"HEAD\") {\n      return (async () => new Response(null, await this.#dispatch(request, executionCtx, env, \"GET\")))();\n    }\n    const path = this.getPath(request, { env });\n    const matchResult = this.router.match(method, path);\n    const c = new Context(request, {\n      path,\n      matchResult,\n      env,\n      executionCtx,\n      notFoundHandler: this.#notFoundHandler\n    });\n    if (matchResult[0].length === 1) {\n      let res;\n      try {\n        res = matchResult[0][0][0][0](c, async () => {\n          c.res = await this.#notFoundHandler(c);\n        });\n      } catch (err) {\n        return this.#handleError(err, c);\n      }\n      return res instanceof Promise ? res.then(\n        (resolved) => resolved || (c.finalized ? c.res : this.#notFoundHandler(c))\n      ).catch((err) => this.#handleError(err, c)) : res ?? this.#notFoundHandler(c);\n    }\n    const composed = compose(matchResult[0], this.errorHandler, this.#notFoundHandler);\n    return (async () => {\n      try {\n        const context = await composed(c);\n        if (!context.finalized) {\n          throw new Error(\n            \"Context is not finalized. Did you forget to return a Response object or `await next()`?\"\n          );\n        }\n        return context.res;\n      } catch (err) {\n        return this.#handleError(err, c);\n      }\n    })();\n  }\n  fetch = (request, ...rest) => {\n    return this.#dispatch(request, rest[1], rest[0], request.method);\n  };\n  request = (input, requestInit, Env, executionCtx) => {\n    if (input instanceof Request) {\n      return this.fetch(requestInit ? new Request(input, requestInit) : input, Env, executionCtx);\n    }\n    input = input.toString();\n    return this.fetch(\n      new Request(\n        /^https?:\\/\\//.test(input) ? input : `http://localhost${mergePath(\"/\", input)}`,\n        requestInit\n      ),\n      Env,\n      executionCtx\n    );\n  };\n  fire = () => {\n    addEventListener(\"fetch\", (event) => {\n      event.respondWith(this.#dispatch(event.request, event, void 0, event.request.method));\n    });\n  };\n};\nexport {\n  Hono as HonoBase\n};\n","// src/compose.ts\nvar compose = (middleware, onError, onNotFound) => {\n  return (context, next) => {\n    let index = -1;\n    return dispatch(0);\n    async function dispatch(i) {\n      if (i <= index) {\n        throw new Error(\"next() called multiple times\");\n      }\n      index = i;\n      let res;\n      let isError = false;\n      let handler;\n      if (middleware[i]) {\n        handler = middleware[i][0][0];\n        context.req.routeIndex = i;\n      } else {\n        handler = i === middleware.length && next || void 0;\n      }\n      if (handler) {\n        try {\n          res = await handler(context, () => dispatch(i + 1));\n        } catch (err) {\n          if (err instanceof Error && onError) {\n            context.error = err;\n            res = await onError(err, context);\n            isError = true;\n          } else {\n            throw err;\n          }\n        }\n      } else {\n        if (context.finalized === false && onNotFound) {\n          res = await onNotFound(context);\n        }\n      }\n      if (res && (context.finalized === false || isError)) {\n        context.res = res;\n      }\n      return context;\n    }\n  };\n};\nexport {\n  compose\n};\n","exports.interopDefault = function (a) {\n  return a && a.__esModule ? a : {default: a};\n};\n\nexports.defineInteropFlag = function (a) {\n  Object.defineProperty(a, '__esModule', {value: true});\n};\n\nexports.exportAll = function (source, dest) {\n  Object.keys(source).forEach(function (key) {\n    if (\n      key === 'default' ||\n      key === '__esModule' ||\n      Object.prototype.hasOwnProperty.call(dest, key)\n    ) {\n      return;\n    }\n\n    Object.defineProperty(dest, key, {\n      enumerable: true,\n      get: function () {\n        return source[key];\n      },\n    });\n  });\n\n  return dest;\n};\n\nexports.export = function (dest, destName, get) {\n  Object.defineProperty(dest, destName, {\n    enumerable: true,\n    get: get,\n  });\n};\n","// src/context.ts\nimport { HonoRequest } from \"./request.js\";\nimport { HtmlEscapedCallbackPhase, resolveCallback } from \"./utils/html.js\";\nvar TEXT_PLAIN = \"text/plain; charset=UTF-8\";\nvar setHeaders = (headers, map = {}) => {\n  for (const key of Object.keys(map)) {\n    headers.set(key, map[key]);\n  }\n  return headers;\n};\nvar Context = class {\n  #rawRequest;\n  #req;\n  env = {};\n  #var;\n  finalized = false;\n  error;\n  #status = 200;\n  #executionCtx;\n  #headers;\n  #preparedHeaders;\n  #res;\n  #isFresh = true;\n  #layout;\n  #renderer;\n  #notFoundHandler;\n  #matchResult;\n  #path;\n  constructor(req, options) {\n    this.#rawRequest = req;\n    if (options) {\n      this.#executionCtx = options.executionCtx;\n      this.env = options.env;\n      this.#notFoundHandler = options.notFoundHandler;\n      this.#path = options.path;\n      this.#matchResult = options.matchResult;\n    }\n  }\n  get req() {\n    this.#req ??= new HonoRequest(this.#rawRequest, this.#path, this.#matchResult);\n    return this.#req;\n  }\n  get event() {\n    if (this.#executionCtx && \"respondWith\" in this.#executionCtx) {\n      return this.#executionCtx;\n    } else {\n      throw Error(\"This context has no FetchEvent\");\n    }\n  }\n  get executionCtx() {\n    if (this.#executionCtx) {\n      return this.#executionCtx;\n    } else {\n      throw Error(\"This context has no ExecutionContext\");\n    }\n  }\n  get res() {\n    this.#isFresh = false;\n    return this.#res ||= new Response(\"404 Not Found\", { status: 404 });\n  }\n  set res(_res) {\n    this.#isFresh = false;\n    if (this.#res && _res) {\n      _res = new Response(_res.body, _res);\n      for (const [k, v] of this.#res.headers.entries()) {\n        if (k === \"content-type\") {\n          continue;\n        }\n        if (k === \"set-cookie\") {\n          const cookies = this.#res.headers.getSetCookie();\n          _res.headers.delete(\"set-cookie\");\n          for (const cookie of cookies) {\n            _res.headers.append(\"set-cookie\", cookie);\n          }\n        } else {\n          _res.headers.set(k, v);\n        }\n      }\n    }\n    this.#res = _res;\n    this.finalized = true;\n  }\n  render = (...args) => {\n    this.#renderer ??= (content) => this.html(content);\n    return this.#renderer(...args);\n  };\n  setLayout = (layout) => this.#layout = layout;\n  getLayout = () => this.#layout;\n  setRenderer = (renderer) => {\n    this.#renderer = renderer;\n  };\n  header = (name, value, options) => {\n    if (this.finalized) {\n      this.#res = new Response(this.#res.body, this.#res);\n    }\n    if (value === void 0) {\n      if (this.#headers) {\n        this.#headers.delete(name);\n      } else if (this.#preparedHeaders) {\n        delete this.#preparedHeaders[name.toLocaleLowerCase()];\n      }\n      if (this.finalized) {\n        this.res.headers.delete(name);\n      }\n      return;\n    }\n    if (options?.append) {\n      if (!this.#headers) {\n        this.#isFresh = false;\n        this.#headers = new Headers(this.#preparedHeaders);\n        this.#preparedHeaders = {};\n      }\n      this.#headers.append(name, value);\n    } else {\n      if (this.#headers) {\n        this.#headers.set(name, value);\n      } else {\n        this.#preparedHeaders ??= {};\n        this.#preparedHeaders[name.toLowerCase()] = value;\n      }\n    }\n    if (this.finalized) {\n      if (options?.append) {\n        this.res.headers.append(name, value);\n      } else {\n        this.res.headers.set(name, value);\n      }\n    }\n  };\n  status = (status) => {\n    this.#isFresh = false;\n    this.#status = status;\n  };\n  set = (key, value) => {\n    this.#var ??= /* @__PURE__ */ new Map();\n    this.#var.set(key, value);\n  };\n  get = (key) => {\n    return this.#var ? this.#var.get(key) : void 0;\n  };\n  get var() {\n    if (!this.#var) {\n      return {};\n    }\n    return Object.fromEntries(this.#var);\n  }\n  #newResponse(data, arg, headers) {\n    if (this.#isFresh && !headers && !arg && this.#status === 200) {\n      return new Response(data, {\n        headers: this.#preparedHeaders\n      });\n    }\n    if (arg && typeof arg !== \"number\") {\n      const header = new Headers(arg.headers);\n      if (this.#headers) {\n        this.#headers.forEach((v, k) => {\n          if (k === \"set-cookie\") {\n            header.append(k, v);\n          } else {\n            header.set(k, v);\n          }\n        });\n      }\n      const headers2 = setHeaders(header, this.#preparedHeaders);\n      return new Response(data, {\n        headers: headers2,\n        status: arg.status ?? this.#status\n      });\n    }\n    const status = typeof arg === \"number\" ? arg : this.#status;\n    this.#preparedHeaders ??= {};\n    this.#headers ??= new Headers();\n    setHeaders(this.#headers, this.#preparedHeaders);\n    if (this.#res) {\n      this.#res.headers.forEach((v, k) => {\n        if (k === \"set-cookie\") {\n          this.#headers?.append(k, v);\n        } else {\n          this.#headers?.set(k, v);\n        }\n      });\n      setHeaders(this.#headers, this.#preparedHeaders);\n    }\n    headers ??= {};\n    for (const [k, v] of Object.entries(headers)) {\n      if (typeof v === \"string\") {\n        this.#headers.set(k, v);\n      } else {\n        this.#headers.delete(k);\n        for (const v2 of v) {\n          this.#headers.append(k, v2);\n        }\n      }\n    }\n    return new Response(data, {\n      status,\n      headers: this.#headers\n    });\n  }\n  newResponse = (...args) => this.#newResponse(...args);\n  body = (data, arg, headers) => {\n    return typeof arg === \"number\" ? this.#newResponse(data, arg, headers) : this.#newResponse(data, arg);\n  };\n  text = (text, arg, headers) => {\n    if (!this.#preparedHeaders) {\n      if (this.#isFresh && !headers && !arg) {\n        return new Response(text);\n      }\n      this.#preparedHeaders = {};\n    }\n    this.#preparedHeaders[\"content-type\"] = TEXT_PLAIN;\n    if (typeof arg === \"number\") {\n      return this.#newResponse(text, arg, headers);\n    }\n    return this.#newResponse(text, arg);\n  };\n  json = (object, arg, headers) => {\n    const body = JSON.stringify(object);\n    this.#preparedHeaders ??= {};\n    this.#preparedHeaders[\"content-type\"] = \"application/json\";\n    return typeof arg === \"number\" ? this.#newResponse(body, arg, headers) : this.#newResponse(body, arg);\n  };\n  html = (html, arg, headers) => {\n    this.#preparedHeaders ??= {};\n    this.#preparedHeaders[\"content-type\"] = \"text/html; charset=UTF-8\";\n    if (typeof html === \"object\") {\n      return resolveCallback(html, HtmlEscapedCallbackPhase.Stringify, false, {}).then((html2) => {\n        return typeof arg === \"number\" ? this.#newResponse(html2, arg, headers) : this.#newResponse(html2, arg);\n      });\n    }\n    return typeof arg === \"number\" ? this.#newResponse(html, arg, headers) : this.#newResponse(html, arg);\n  };\n  redirect = (location, status) => {\n    this.#headers ??= new Headers();\n    this.#headers.set(\"Location\", String(location));\n    return this.newResponse(null, status ?? 302);\n  };\n  notFound = () => {\n    this.#notFoundHandler ??= () => new Response();\n    return this.#notFoundHandler(this);\n  };\n};\nexport {\n  Context,\n  TEXT_PLAIN\n};\n","// src/request.ts\nimport { parseBody } from \"./utils/body.js\";\nimport { decodeURIComponent_, getQueryParam, getQueryParams, tryDecode } from \"./utils/url.js\";\nvar tryDecodeURIComponent = (str) => tryDecode(str, decodeURIComponent_);\nvar HonoRequest = class {\n  raw;\n  #validatedData;\n  #matchResult;\n  routeIndex = 0;\n  path;\n  bodyCache = {};\n  constructor(request, path = \"/\", matchResult = [[]]) {\n    this.raw = request;\n    this.path = path;\n    this.#matchResult = matchResult;\n    this.#validatedData = {};\n  }\n  param(key) {\n    return key ? this.#getDecodedParam(key) : this.#getAllDecodedParams();\n  }\n  #getDecodedParam(key) {\n    const paramKey = this.#matchResult[0][this.routeIndex][1][key];\n    const param = this.#getParamValue(paramKey);\n    return param ? /\\%/.test(param) ? tryDecodeURIComponent(param) : param : void 0;\n  }\n  #getAllDecodedParams() {\n    const decoded = {};\n    const keys = Object.keys(this.#matchResult[0][this.routeIndex][1]);\n    for (const key of keys) {\n      const value = this.#getParamValue(this.#matchResult[0][this.routeIndex][1][key]);\n      if (value && typeof value === \"string\") {\n        decoded[key] = /\\%/.test(value) ? tryDecodeURIComponent(value) : value;\n      }\n    }\n    return decoded;\n  }\n  #getParamValue(paramKey) {\n    return this.#matchResult[1] ? this.#matchResult[1][paramKey] : paramKey;\n  }\n  query(key) {\n    return getQueryParam(this.url, key);\n  }\n  queries(key) {\n    return getQueryParams(this.url, key);\n  }\n  header(name) {\n    if (name) {\n      return this.raw.headers.get(name) ?? void 0;\n    }\n    const headerData = {};\n    this.raw.headers.forEach((value, key) => {\n      headerData[key] = value;\n    });\n    return headerData;\n  }\n  async parseBody(options) {\n    return this.bodyCache.parsedBody ??= await parseBody(this, options);\n  }\n  #cachedBody = (key) => {\n    const { bodyCache, raw } = this;\n    const cachedBody = bodyCache[key];\n    if (cachedBody) {\n      return cachedBody;\n    }\n    const anyCachedKey = Object.keys(bodyCache)[0];\n    if (anyCachedKey) {\n      return bodyCache[anyCachedKey].then((body) => {\n        if (anyCachedKey === \"json\") {\n          body = JSON.stringify(body);\n        }\n        return new Response(body)[key]();\n      });\n    }\n    return bodyCache[key] = raw[key]();\n  };\n  json() {\n    return this.#cachedBody(\"json\");\n  }\n  text() {\n    return this.#cachedBody(\"text\");\n  }\n  arrayBuffer() {\n    return this.#cachedBody(\"arrayBuffer\");\n  }\n  blob() {\n    return this.#cachedBody(\"blob\");\n  }\n  formData() {\n    return this.#cachedBody(\"formData\");\n  }\n  addValidatedData(target, data) {\n    this.#validatedData[target] = data;\n  }\n  valid(target) {\n    return this.#validatedData[target];\n  }\n  get url() {\n    return this.raw.url;\n  }\n  get method() {\n    return this.raw.method;\n  }\n  get matchedRoutes() {\n    return this.#matchResult[0].map(([[, route]]) => route);\n  }\n  get routePath() {\n    return this.#matchResult[0].map(([[, route]]) => route)[this.routeIndex].path;\n  }\n};\nexport {\n  HonoRequest\n};\n","// src/utils/body.ts\nimport { HonoRequest } from \"../request.js\";\nvar parseBody = async (request, options = /* @__PURE__ */ Object.create(null)) => {\n  const { all = false, dot = false } = options;\n  const headers = request instanceof HonoRequest ? request.raw.headers : request.headers;\n  const contentType = headers.get(\"Content-Type\");\n  if (contentType?.startsWith(\"multipart/form-data\") || contentType?.startsWith(\"application/x-www-form-urlencoded\")) {\n    return parseFormData(request, { all, dot });\n  }\n  return {};\n};\nasync function parseFormData(request, options) {\n  const formData = await request.formData();\n  if (formData) {\n    return convertFormDataToBodyData(formData, options);\n  }\n  return {};\n}\nfunction convertFormDataToBodyData(formData, options) {\n  const form = /* @__PURE__ */ Object.create(null);\n  formData.forEach((value, key) => {\n    const shouldParseAllValues = options.all || key.endsWith(\"[]\");\n    if (!shouldParseAllValues) {\n      form[key] = value;\n    } else {\n      handleParsingAllValues(form, key, value);\n    }\n  });\n  if (options.dot) {\n    Object.entries(form).forEach(([key, value]) => {\n      const shouldParseDotValues = key.includes(\".\");\n      if (shouldParseDotValues) {\n        handleParsingNestedValues(form, key, value);\n        delete form[key];\n      }\n    });\n  }\n  return form;\n}\nvar handleParsingAllValues = (form, key, value) => {\n  if (form[key] !== void 0) {\n    if (Array.isArray(form[key])) {\n      ;\n      form[key].push(value);\n    } else {\n      form[key] = [form[key], value];\n    }\n  } else {\n    form[key] = value;\n  }\n};\nvar handleParsingNestedValues = (form, key, value) => {\n  let nestedForm = form;\n  const keys = key.split(\".\");\n  keys.forEach((key2, index) => {\n    if (index === keys.length - 1) {\n      nestedForm[key2] = value;\n    } else {\n      if (!nestedForm[key2] || typeof nestedForm[key2] !== \"object\" || Array.isArray(nestedForm[key2]) || nestedForm[key2] instanceof File) {\n        nestedForm[key2] = /* @__PURE__ */ Object.create(null);\n      }\n      nestedForm = nestedForm[key2];\n    }\n  });\n};\nexport {\n  parseBody\n};\n","// src/utils/url.ts\nvar splitPath = (path) => {\n  const paths = path.split(\"/\");\n  if (paths[0] === \"\") {\n    paths.shift();\n  }\n  return paths;\n};\nvar splitRoutingPath = (routePath) => {\n  const { groups, path } = extractGroupsFromPath(routePath);\n  const paths = splitPath(path);\n  return replaceGroupMarks(paths, groups);\n};\nvar extractGroupsFromPath = (path) => {\n  const groups = [];\n  path = path.replace(/\\{[^}]+\\}/g, (match, index) => {\n    const mark = `@${index}`;\n    groups.push([mark, match]);\n    return mark;\n  });\n  return { groups, path };\n};\nvar replaceGroupMarks = (paths, groups) => {\n  for (let i = groups.length - 1; i >= 0; i--) {\n    const [mark] = groups[i];\n    for (let j = paths.length - 1; j >= 0; j--) {\n      if (paths[j].includes(mark)) {\n        paths[j] = paths[j].replace(mark, groups[i][1]);\n        break;\n      }\n    }\n  }\n  return paths;\n};\nvar patternCache = {};\nvar getPattern = (label, next) => {\n  if (label === \"*\") {\n    return \"*\";\n  }\n  const match = label.match(/^\\:([^\\{\\}]+)(?:\\{(.+)\\})?$/);\n  if (match) {\n    const cacheKey = `${label}#${next}`;\n    if (!patternCache[cacheKey]) {\n      if (match[2]) {\n        patternCache[cacheKey] = next && next[0] !== \":\" && next[0] !== \"*\" ? [cacheKey, match[1], new RegExp(`^${match[2]}(?=/${next})`)] : [label, match[1], new RegExp(`^${match[2]}$`)];\n      } else {\n        patternCache[cacheKey] = [label, match[1], true];\n      }\n    }\n    return patternCache[cacheKey];\n  }\n  return null;\n};\nvar tryDecode = (str, decoder) => {\n  try {\n    return decoder(str);\n  } catch {\n    return str.replace(/(?:%[0-9A-Fa-f]{2})+/g, (match) => {\n      try {\n        return decoder(match);\n      } catch {\n        return match;\n      }\n    });\n  }\n};\nvar tryDecodeURI = (str) => tryDecode(str, decodeURI);\nvar getPath = (request) => {\n  const url = request.url;\n  const start = url.indexOf(\"/\", 8);\n  let i = start;\n  for (; i < url.length; i++) {\n    const charCode = url.charCodeAt(i);\n    if (charCode === 37) {\n      const queryIndex = url.indexOf(\"?\", i);\n      const path = url.slice(start, queryIndex === -1 ? void 0 : queryIndex);\n      return tryDecodeURI(path.includes(\"%25\") ? path.replace(/%25/g, \"%2525\") : path);\n    } else if (charCode === 63) {\n      break;\n    }\n  }\n  return url.slice(start, i);\n};\nvar getQueryStrings = (url) => {\n  const queryIndex = url.indexOf(\"?\", 8);\n  return queryIndex === -1 ? \"\" : \"?\" + url.slice(queryIndex + 1);\n};\nvar getPathNoStrict = (request) => {\n  const result = getPath(request);\n  return result.length > 1 && result.at(-1) === \"/\" ? result.slice(0, -1) : result;\n};\nvar mergePath = (base, sub, ...rest) => {\n  if (rest.length) {\n    sub = mergePath(sub, ...rest);\n  }\n  return `${base?.[0] === \"/\" ? \"\" : \"/\"}${base}${sub === \"/\" ? \"\" : `${base?.at(-1) === \"/\" ? \"\" : \"/\"}${sub?.[0] === \"/\" ? sub.slice(1) : sub}`}`;\n};\nvar checkOptionalParameter = (path) => {\n  if (path.charCodeAt(path.length - 1) !== 63 || !path.includes(\":\")) {\n    return null;\n  }\n  const segments = path.split(\"/\");\n  const results = [];\n  let basePath = \"\";\n  segments.forEach((segment) => {\n    if (segment !== \"\" && !/\\:/.test(segment)) {\n      basePath += \"/\" + segment;\n    } else if (/\\:/.test(segment)) {\n      if (/\\?/.test(segment)) {\n        if (results.length === 0 && basePath === \"\") {\n          results.push(\"/\");\n        } else {\n          results.push(basePath);\n        }\n        const optionalSegment = segment.replace(\"?\", \"\");\n        basePath += \"/\" + optionalSegment;\n        results.push(basePath);\n      } else {\n        basePath += \"/\" + segment;\n      }\n    }\n  });\n  return results.filter((v, i, a) => a.indexOf(v) === i);\n};\nvar _decodeURI = (value) => {\n  if (!/[%+]/.test(value)) {\n    return value;\n  }\n  if (value.indexOf(\"+\") !== -1) {\n    value = value.replace(/\\+/g, \" \");\n  }\n  return value.indexOf(\"%\") !== -1 ? decodeURIComponent_(value) : value;\n};\nvar _getQueryParam = (url, key, multiple) => {\n  let encoded;\n  if (!multiple && key && !/[%+]/.test(key)) {\n    let keyIndex2 = url.indexOf(`?${key}`, 8);\n    if (keyIndex2 === -1) {\n      keyIndex2 = url.indexOf(`&${key}`, 8);\n    }\n    while (keyIndex2 !== -1) {\n      const trailingKeyCode = url.charCodeAt(keyIndex2 + key.length + 1);\n      if (trailingKeyCode === 61) {\n        const valueIndex = keyIndex2 + key.length + 2;\n        const endIndex = url.indexOf(\"&\", valueIndex);\n        return _decodeURI(url.slice(valueIndex, endIndex === -1 ? void 0 : endIndex));\n      } else if (trailingKeyCode == 38 || isNaN(trailingKeyCode)) {\n        return \"\";\n      }\n      keyIndex2 = url.indexOf(`&${key}`, keyIndex2 + 1);\n    }\n    encoded = /[%+]/.test(url);\n    if (!encoded) {\n      return void 0;\n    }\n  }\n  const results = {};\n  encoded ??= /[%+]/.test(url);\n  let keyIndex = url.indexOf(\"?\", 8);\n  while (keyIndex !== -1) {\n    const nextKeyIndex = url.indexOf(\"&\", keyIndex + 1);\n    let valueIndex = url.indexOf(\"=\", keyIndex);\n    if (valueIndex > nextKeyIndex && nextKeyIndex !== -1) {\n      valueIndex = -1;\n    }\n    let name = url.slice(\n      keyIndex + 1,\n      valueIndex === -1 ? nextKeyIndex === -1 ? void 0 : nextKeyIndex : valueIndex\n    );\n    if (encoded) {\n      name = _decodeURI(name);\n    }\n    keyIndex = nextKeyIndex;\n    if (name === \"\") {\n      continue;\n    }\n    let value;\n    if (valueIndex === -1) {\n      value = \"\";\n    } else {\n      value = url.slice(valueIndex + 1, nextKeyIndex === -1 ? void 0 : nextKeyIndex);\n      if (encoded) {\n        value = _decodeURI(value);\n      }\n    }\n    if (multiple) {\n      if (!(results[name] && Array.isArray(results[name]))) {\n        results[name] = [];\n      }\n      ;\n      results[name].push(value);\n    } else {\n      results[name] ??= value;\n    }\n  }\n  return key ? results[key] : results;\n};\nvar getQueryParam = _getQueryParam;\nvar getQueryParams = (url, key) => {\n  return _getQueryParam(url, key, true);\n};\nvar decodeURIComponent_ = decodeURIComponent;\nexport {\n  checkOptionalParameter,\n  decodeURIComponent_,\n  getPath,\n  getPathNoStrict,\n  getPattern,\n  getQueryParam,\n  getQueryParams,\n  getQueryStrings,\n  mergePath,\n  splitPath,\n  splitRoutingPath,\n  tryDecode\n};\n","// src/utils/html.ts\nvar HtmlEscapedCallbackPhase = {\n  Stringify: 1,\n  BeforeStream: 2,\n  Stream: 3\n};\nvar raw = (value, callbacks) => {\n  const escapedString = new String(value);\n  escapedString.isEscaped = true;\n  escapedString.callbacks = callbacks;\n  return escapedString;\n};\nvar escapeRe = /[&<>'\"]/;\nvar stringBufferToString = async (buffer, callbacks) => {\n  let str = \"\";\n  callbacks ||= [];\n  const resolvedBuffer = await Promise.all(buffer);\n  for (let i = resolvedBuffer.length - 1; ; i--) {\n    str += resolvedBuffer[i];\n    i--;\n    if (i < 0) {\n      break;\n    }\n    let r = resolvedBuffer[i];\n    if (typeof r === \"object\") {\n      callbacks.push(...r.callbacks || []);\n    }\n    const isEscaped = r.isEscaped;\n    r = await (typeof r === \"object\" ? r.toString() : r);\n    if (typeof r === \"object\") {\n      callbacks.push(...r.callbacks || []);\n    }\n    if (r.isEscaped ?? isEscaped) {\n      str += r;\n    } else {\n      const buf = [str];\n      escapeToBuffer(r, buf);\n      str = buf[0];\n    }\n  }\n  return raw(str, callbacks);\n};\nvar escapeToBuffer = (str, buffer) => {\n  const match = str.search(escapeRe);\n  if (match === -1) {\n    buffer[0] += str;\n    return;\n  }\n  let escape;\n  let index;\n  let lastIndex = 0;\n  for (index = match; index < str.length; index++) {\n    switch (str.charCodeAt(index)) {\n      case 34:\n        escape = \"&quot;\";\n        break;\n      case 39:\n        escape = \"&#39;\";\n        break;\n      case 38:\n        escape = \"&amp;\";\n        break;\n      case 60:\n        escape = \"&lt;\";\n        break;\n      case 62:\n        escape = \"&gt;\";\n        break;\n      default:\n        continue;\n    }\n    buffer[0] += str.substring(lastIndex, index) + escape;\n    lastIndex = index + 1;\n  }\n  buffer[0] += str.substring(lastIndex, index);\n};\nvar resolveCallbackSync = (str) => {\n  const callbacks = str.callbacks;\n  if (!callbacks?.length) {\n    return str;\n  }\n  const buffer = [str];\n  const context = {};\n  callbacks.forEach((c) => c({ phase: HtmlEscapedCallbackPhase.Stringify, buffer, context }));\n  return buffer[0];\n};\nvar resolveCallback = async (str, phase, preserveCallbacks, context, buffer) => {\n  if (typeof str === \"object\" && !(str instanceof String)) {\n    if (!(str instanceof Promise)) {\n      str = str.toString();\n    }\n    if (str instanceof Promise) {\n      str = await str;\n    }\n  }\n  const callbacks = str.callbacks;\n  if (!callbacks?.length) {\n    return Promise.resolve(str);\n  }\n  if (buffer) {\n    buffer[0] += str;\n  } else {\n    buffer = [str];\n  }\n  const resStr = Promise.all(callbacks.map((c) => c({ phase, buffer, context }))).then(\n    (res) => Promise.all(\n      res.filter(Boolean).map((str2) => resolveCallback(str2, phase, false, context, buffer))\n    ).then(() => buffer[0])\n  );\n  if (preserveCallbacks) {\n    return raw(await resStr, callbacks);\n  } else {\n    return resStr;\n  }\n};\nexport {\n  HtmlEscapedCallbackPhase,\n  escapeToBuffer,\n  raw,\n  resolveCallback,\n  resolveCallbackSync,\n  stringBufferToString\n};\n","// src/router.ts\nvar METHOD_NAME_ALL = \"ALL\";\nvar METHOD_NAME_ALL_LOWERCASE = \"all\";\nvar METHODS = [\"get\", \"post\", \"put\", \"delete\", \"options\", \"patch\"];\nvar MESSAGE_MATCHER_IS_ALREADY_BUILT = \"Can not add a route since the matcher is already built.\";\nvar UnsupportedPathError = class extends Error {\n};\nexport {\n  MESSAGE_MATCHER_IS_ALREADY_BUILT,\n  METHODS,\n  METHOD_NAME_ALL,\n  METHOD_NAME_ALL_LOWERCASE,\n  UnsupportedPathError\n};\n","// src/utils/constants.ts\nvar COMPOSED_HANDLER = \"__COMPOSED_HANDLER\";\nexport {\n  COMPOSED_HANDLER\n};\n","// src/router/reg-exp-router/index.ts\nimport { RegExpRouter } from \"./router.js\";\nexport {\n  RegExpRouter\n};\n","// src/router/reg-exp-router/router.ts\nimport {\n  MESSAGE_MATCHER_IS_ALREADY_BUILT,\n  METHOD_NAME_ALL,\n  UnsupportedPathError\n} from \"../../router.js\";\nimport { checkOptionalParameter } from \"../../utils/url.js\";\nimport { PATH_ERROR } from \"./node.js\";\nimport { Trie } from \"./trie.js\";\nvar emptyParam = [];\nvar nullMatcher = [/^$/, [], /* @__PURE__ */ Object.create(null)];\nvar wildcardRegExpCache = /* @__PURE__ */ Object.create(null);\nfunction buildWildcardRegExp(path) {\n  return wildcardRegExpCache[path] ??= new RegExp(\n    path === \"*\" ? \"\" : `^${path.replace(\n      /\\/\\*$|([.\\\\+*[^\\]$()])/g,\n      (_, metaChar) => metaChar ? `\\\\${metaChar}` : \"(?:|/.*)\"\n    )}$`\n  );\n}\nfunction clearWildcardRegExpCache() {\n  wildcardRegExpCache = /* @__PURE__ */ Object.create(null);\n}\nfunction buildMatcherFromPreprocessedRoutes(routes) {\n  const trie = new Trie();\n  const handlerData = [];\n  if (routes.length === 0) {\n    return nullMatcher;\n  }\n  const routesWithStaticPathFlag = routes.map(\n    (route) => [!/\\*|\\/:/.test(route[0]), ...route]\n  ).sort(\n    ([isStaticA, pathA], [isStaticB, pathB]) => isStaticA ? 1 : isStaticB ? -1 : pathA.length - pathB.length\n  );\n  const staticMap = /* @__PURE__ */ Object.create(null);\n  for (let i = 0, j = -1, len = routesWithStaticPathFlag.length; i < len; i++) {\n    const [pathErrorCheckOnly, path, handlers] = routesWithStaticPathFlag[i];\n    if (pathErrorCheckOnly) {\n      staticMap[path] = [handlers.map(([h]) => [h, /* @__PURE__ */ Object.create(null)]), emptyParam];\n    } else {\n      j++;\n    }\n    let paramAssoc;\n    try {\n      paramAssoc = trie.insert(path, j, pathErrorCheckOnly);\n    } catch (e) {\n      throw e === PATH_ERROR ? new UnsupportedPathError(path) : e;\n    }\n    if (pathErrorCheckOnly) {\n      continue;\n    }\n    handlerData[j] = handlers.map(([h, paramCount]) => {\n      const paramIndexMap = /* @__PURE__ */ Object.create(null);\n      paramCount -= 1;\n      for (; paramCount >= 0; paramCount--) {\n        const [key, value] = paramAssoc[paramCount];\n        paramIndexMap[key] = value;\n      }\n      return [h, paramIndexMap];\n    });\n  }\n  const [regexp, indexReplacementMap, paramReplacementMap] = trie.buildRegExp();\n  for (let i = 0, len = handlerData.length; i < len; i++) {\n    for (let j = 0, len2 = handlerData[i].length; j < len2; j++) {\n      const map = handlerData[i][j]?.[1];\n      if (!map) {\n        continue;\n      }\n      const keys = Object.keys(map);\n      for (let k = 0, len3 = keys.length; k < len3; k++) {\n        map[keys[k]] = paramReplacementMap[map[keys[k]]];\n      }\n    }\n  }\n  const handlerMap = [];\n  for (const i in indexReplacementMap) {\n    handlerMap[i] = handlerData[indexReplacementMap[i]];\n  }\n  return [regexp, handlerMap, staticMap];\n}\nfunction findMiddleware(middleware, path) {\n  if (!middleware) {\n    return void 0;\n  }\n  for (const k of Object.keys(middleware).sort((a, b) => b.length - a.length)) {\n    if (buildWildcardRegExp(k).test(path)) {\n      return [...middleware[k]];\n    }\n  }\n  return void 0;\n}\nvar RegExpRouter = class {\n  name = \"RegExpRouter\";\n  #middleware;\n  #routes;\n  constructor() {\n    this.#middleware = { [METHOD_NAME_ALL]: /* @__PURE__ */ Object.create(null) };\n    this.#routes = { [METHOD_NAME_ALL]: /* @__PURE__ */ Object.create(null) };\n  }\n  add(method, path, handler) {\n    const middleware = this.#middleware;\n    const routes = this.#routes;\n    if (!middleware || !routes) {\n      throw new Error(MESSAGE_MATCHER_IS_ALREADY_BUILT);\n    }\n    if (!middleware[method]) {\n      ;\n      [middleware, routes].forEach((handlerMap) => {\n        handlerMap[method] = /* @__PURE__ */ Object.create(null);\n        Object.keys(handlerMap[METHOD_NAME_ALL]).forEach((p) => {\n          handlerMap[method][p] = [...handlerMap[METHOD_NAME_ALL][p]];\n        });\n      });\n    }\n    if (path === \"/*\") {\n      path = \"*\";\n    }\n    const paramCount = (path.match(/\\/:/g) || []).length;\n    if (/\\*$/.test(path)) {\n      const re = buildWildcardRegExp(path);\n      if (method === METHOD_NAME_ALL) {\n        Object.keys(middleware).forEach((m) => {\n          middleware[m][path] ||= findMiddleware(middleware[m], path) || findMiddleware(middleware[METHOD_NAME_ALL], path) || [];\n        });\n      } else {\n        middleware[method][path] ||= findMiddleware(middleware[method], path) || findMiddleware(middleware[METHOD_NAME_ALL], path) || [];\n      }\n      Object.keys(middleware).forEach((m) => {\n        if (method === METHOD_NAME_ALL || method === m) {\n          Object.keys(middleware[m]).forEach((p) => {\n            re.test(p) && middleware[m][p].push([handler, paramCount]);\n          });\n        }\n      });\n      Object.keys(routes).forEach((m) => {\n        if (method === METHOD_NAME_ALL || method === m) {\n          Object.keys(routes[m]).forEach(\n            (p) => re.test(p) && routes[m][p].push([handler, paramCount])\n          );\n        }\n      });\n      return;\n    }\n    const paths = checkOptionalParameter(path) || [path];\n    for (let i = 0, len = paths.length; i < len; i++) {\n      const path2 = paths[i];\n      Object.keys(routes).forEach((m) => {\n        if (method === METHOD_NAME_ALL || method === m) {\n          routes[m][path2] ||= [\n            ...findMiddleware(middleware[m], path2) || findMiddleware(middleware[METHOD_NAME_ALL], path2) || []\n          ];\n          routes[m][path2].push([handler, paramCount - len + i + 1]);\n        }\n      });\n    }\n  }\n  match(method, path) {\n    clearWildcardRegExpCache();\n    const matchers = this.#buildAllMatchers();\n    this.match = (method2, path2) => {\n      const matcher = matchers[method2] || matchers[METHOD_NAME_ALL];\n      const staticMatch = matcher[2][path2];\n      if (staticMatch) {\n        return staticMatch;\n      }\n      const match = path2.match(matcher[0]);\n      if (!match) {\n        return [[], emptyParam];\n      }\n      const index = match.indexOf(\"\", 1);\n      return [matcher[1][index], match];\n    };\n    return this.match(method, path);\n  }\n  #buildAllMatchers() {\n    const matchers = /* @__PURE__ */ Object.create(null);\n    Object.keys(this.#routes).concat(Object.keys(this.#middleware)).forEach((method) => {\n      matchers[method] ||= this.#buildMatcher(method);\n    });\n    this.#middleware = this.#routes = void 0;\n    return matchers;\n  }\n  #buildMatcher(method) {\n    const routes = [];\n    let hasOwnRoute = method === METHOD_NAME_ALL;\n    [this.#middleware, this.#routes].forEach((r) => {\n      const ownRoute = r[method] ? Object.keys(r[method]).map((path) => [path, r[method][path]]) : [];\n      if (ownRoute.length !== 0) {\n        hasOwnRoute ||= true;\n        routes.push(...ownRoute);\n      } else if (method !== METHOD_NAME_ALL) {\n        routes.push(\n          ...Object.keys(r[METHOD_NAME_ALL]).map((path) => [path, r[METHOD_NAME_ALL][path]])\n        );\n      }\n    });\n    if (!hasOwnRoute) {\n      return null;\n    } else {\n      return buildMatcherFromPreprocessedRoutes(routes);\n    }\n  }\n};\nexport {\n  RegExpRouter\n};\n","// src/router/reg-exp-router/node.ts\nvar LABEL_REG_EXP_STR = \"[^/]+\";\nvar ONLY_WILDCARD_REG_EXP_STR = \".*\";\nvar TAIL_WILDCARD_REG_EXP_STR = \"(?:|/.*)\";\nvar PATH_ERROR = Symbol();\nvar regExpMetaChars = new Set(\".\\\\+*[^]$()\");\nfunction compareKey(a, b) {\n  if (a.length === 1) {\n    return b.length === 1 ? a < b ? -1 : 1 : -1;\n  }\n  if (b.length === 1) {\n    return 1;\n  }\n  if (a === ONLY_WILDCARD_REG_EXP_STR || a === TAIL_WILDCARD_REG_EXP_STR) {\n    return 1;\n  } else if (b === ONLY_WILDCARD_REG_EXP_STR || b === TAIL_WILDCARD_REG_EXP_STR) {\n    return -1;\n  }\n  if (a === LABEL_REG_EXP_STR) {\n    return 1;\n  } else if (b === LABEL_REG_EXP_STR) {\n    return -1;\n  }\n  return a.length === b.length ? a < b ? -1 : 1 : b.length - a.length;\n}\nvar Node = class {\n  #index;\n  #varIndex;\n  #children = /* @__PURE__ */ Object.create(null);\n  insert(tokens, index, paramMap, context, pathErrorCheckOnly) {\n    if (tokens.length === 0) {\n      if (this.#index !== void 0) {\n        throw PATH_ERROR;\n      }\n      if (pathErrorCheckOnly) {\n        return;\n      }\n      this.#index = index;\n      return;\n    }\n    const [token, ...restTokens] = tokens;\n    const pattern = token === \"*\" ? restTokens.length === 0 ? [\"\", \"\", ONLY_WILDCARD_REG_EXP_STR] : [\"\", \"\", LABEL_REG_EXP_STR] : token === \"/*\" ? [\"\", \"\", TAIL_WILDCARD_REG_EXP_STR] : token.match(/^\\:([^\\{\\}]+)(?:\\{(.+)\\})?$/);\n    let node;\n    if (pattern) {\n      const name = pattern[1];\n      let regexpStr = pattern[2] || LABEL_REG_EXP_STR;\n      if (name && pattern[2]) {\n        regexpStr = regexpStr.replace(/^\\((?!\\?:)(?=[^)]+\\)$)/, \"(?:\");\n        if (/\\((?!\\?:)/.test(regexpStr)) {\n          throw PATH_ERROR;\n        }\n      }\n      node = this.#children[regexpStr];\n      if (!node) {\n        if (Object.keys(this.#children).some(\n          (k) => k !== ONLY_WILDCARD_REG_EXP_STR && k !== TAIL_WILDCARD_REG_EXP_STR\n        )) {\n          throw PATH_ERROR;\n        }\n        if (pathErrorCheckOnly) {\n          return;\n        }\n        node = this.#children[regexpStr] = new Node();\n        if (name !== \"\") {\n          node.#varIndex = context.varIndex++;\n        }\n      }\n      if (!pathErrorCheckOnly && name !== \"\") {\n        paramMap.push([name, node.#varIndex]);\n      }\n    } else {\n      node = this.#children[token];\n      if (!node) {\n        if (Object.keys(this.#children).some(\n          (k) => k.length > 1 && k !== ONLY_WILDCARD_REG_EXP_STR && k !== TAIL_WILDCARD_REG_EXP_STR\n        )) {\n          throw PATH_ERROR;\n        }\n        if (pathErrorCheckOnly) {\n          return;\n        }\n        node = this.#children[token] = new Node();\n      }\n    }\n    node.insert(restTokens, index, paramMap, context, pathErrorCheckOnly);\n  }\n  buildRegExpStr() {\n    const childKeys = Object.keys(this.#children).sort(compareKey);\n    const strList = childKeys.map((k) => {\n      const c = this.#children[k];\n      return (typeof c.#varIndex === \"number\" ? `(${k})@${c.#varIndex}` : regExpMetaChars.has(k) ? `\\\\${k}` : k) + c.buildRegExpStr();\n    });\n    if (typeof this.#index === \"number\") {\n      strList.unshift(`#${this.#index}`);\n    }\n    if (strList.length === 0) {\n      return \"\";\n    }\n    if (strList.length === 1) {\n      return strList[0];\n    }\n    return \"(?:\" + strList.join(\"|\") + \")\";\n  }\n};\nexport {\n  Node,\n  PATH_ERROR\n};\n","// src/router/reg-exp-router/trie.ts\nimport { Node } from \"./node.js\";\nvar Trie = class {\n  #context = { varIndex: 0 };\n  #root = new Node();\n  insert(path, index, pathErrorCheckOnly) {\n    const paramAssoc = [];\n    const groups = [];\n    for (let i = 0; ; ) {\n      let replaced = false;\n      path = path.replace(/\\{[^}]+\\}/g, (m) => {\n        const mark = `@\\\\${i}`;\n        groups[i] = [mark, m];\n        i++;\n        replaced = true;\n        return mark;\n      });\n      if (!replaced) {\n        break;\n      }\n    }\n    const tokens = path.match(/(?::[^\\/]+)|(?:\\/\\*$)|./g) || [];\n    for (let i = groups.length - 1; i >= 0; i--) {\n      const [mark] = groups[i];\n      for (let j = tokens.length - 1; j >= 0; j--) {\n        if (tokens[j].indexOf(mark) !== -1) {\n          tokens[j] = tokens[j].replace(mark, groups[i][1]);\n          break;\n        }\n      }\n    }\n    this.#root.insert(tokens, index, paramAssoc, this.#context, pathErrorCheckOnly);\n    return paramAssoc;\n  }\n  buildRegExp() {\n    let regexp = this.#root.buildRegExpStr();\n    if (regexp === \"\") {\n      return [/^$/, [], []];\n    }\n    let captureIndex = 0;\n    const indexReplacementMap = [];\n    const paramReplacementMap = [];\n    regexp = regexp.replace(/#(\\d+)|@(\\d+)|\\.\\*\\$/g, (_, handlerIndex, paramIndex) => {\n      if (handlerIndex !== void 0) {\n        indexReplacementMap[++captureIndex] = Number(handlerIndex);\n        return \"$()\";\n      }\n      if (paramIndex !== void 0) {\n        paramReplacementMap[Number(paramIndex)] = ++captureIndex;\n        return \"\";\n      }\n      return \"\";\n    });\n    return [new RegExp(`^${regexp}`), indexReplacementMap, paramReplacementMap];\n  }\n};\nexport {\n  Trie\n};\n","// src/router/smart-router/index.ts\nimport { SmartRouter } from \"./router.js\";\nexport {\n  SmartRouter\n};\n","// src/router/smart-router/router.ts\nimport { MESSAGE_MATCHER_IS_ALREADY_BUILT, UnsupportedPathError } from \"../../router.js\";\nvar SmartRouter = class {\n  name = \"SmartRouter\";\n  #routers = [];\n  #routes = [];\n  constructor(init) {\n    this.#routers = init.routers;\n  }\n  add(method, path, handler) {\n    if (!this.#routes) {\n      throw new Error(MESSAGE_MATCHER_IS_ALREADY_BUILT);\n    }\n    this.#routes.push([method, path, handler]);\n  }\n  match(method, path) {\n    if (!this.#routes) {\n      throw new Error(\"Fatal error\");\n    }\n    const routers = this.#routers;\n    const routes = this.#routes;\n    const len = routers.length;\n    let i = 0;\n    let res;\n    for (; i < len; i++) {\n      const router = routers[i];\n      try {\n        for (let i2 = 0, len2 = routes.length; i2 < len2; i2++) {\n          router.add(...routes[i2]);\n        }\n        res = router.match(method, path);\n      } catch (e) {\n        if (e instanceof UnsupportedPathError) {\n          continue;\n        }\n        throw e;\n      }\n      this.match = router.match.bind(router);\n      this.#routers = [router];\n      this.#routes = void 0;\n      break;\n    }\n    if (i === len) {\n      throw new Error(\"Fatal error\");\n    }\n    this.name = `SmartRouter + ${this.activeRouter.name}`;\n    return res;\n  }\n  get activeRouter() {\n    if (this.#routes || this.#routers.length !== 1) {\n      throw new Error(\"No active router has been determined yet.\");\n    }\n    return this.#routers[0];\n  }\n};\nexport {\n  SmartRouter\n};\n","// src/router/trie-router/index.ts\nimport { TrieRouter } from \"./router.js\";\nexport {\n  TrieRouter\n};\n","// src/router/trie-router/router.ts\nimport { checkOptionalParameter } from \"../../utils/url.js\";\nimport { Node } from \"./node.js\";\nvar TrieRouter = class {\n  name = \"TrieRouter\";\n  #node;\n  constructor() {\n    this.#node = new Node();\n  }\n  add(method, path, handler) {\n    const results = checkOptionalParameter(path);\n    if (results) {\n      for (let i = 0, len = results.length; i < len; i++) {\n        this.#node.insert(method, results[i], handler);\n      }\n      return;\n    }\n    this.#node.insert(method, path, handler);\n  }\n  match(method, path) {\n    return this.#node.search(method, path);\n  }\n};\nexport {\n  TrieRouter\n};\n","// src/router/trie-router/node.ts\nimport { METHOD_NAME_ALL } from \"../../router.js\";\nimport { getPattern, splitPath, splitRoutingPath } from \"../../utils/url.js\";\nvar emptyParams = /* @__PURE__ */ Object.create(null);\nvar Node = class {\n  #methods;\n  #children;\n  #patterns;\n  #order = 0;\n  #params = emptyParams;\n  constructor(method, handler, children) {\n    this.#children = children || /* @__PURE__ */ Object.create(null);\n    this.#methods = [];\n    if (method && handler) {\n      const m = /* @__PURE__ */ Object.create(null);\n      m[method] = { handler, possibleKeys: [], score: 0 };\n      this.#methods = [m];\n    }\n    this.#patterns = [];\n  }\n  insert(method, path, handler) {\n    this.#order = ++this.#order;\n    let curNode = this;\n    const parts = splitRoutingPath(path);\n    const possibleKeys = [];\n    for (let i = 0, len = parts.length; i < len; i++) {\n      const p = parts[i];\n      const nextP = parts[i + 1];\n      const pattern = getPattern(p, nextP);\n      const key = Array.isArray(pattern) ? pattern[0] : p;\n      if (Object.keys(curNode.#children).includes(key)) {\n        curNode = curNode.#children[key];\n        const pattern2 = getPattern(p, nextP);\n        if (pattern2) {\n          possibleKeys.push(pattern2[1]);\n        }\n        continue;\n      }\n      curNode.#children[key] = new Node();\n      if (pattern) {\n        curNode.#patterns.push(pattern);\n        possibleKeys.push(pattern[1]);\n      }\n      curNode = curNode.#children[key];\n    }\n    const m = /* @__PURE__ */ Object.create(null);\n    const handlerSet = {\n      handler,\n      possibleKeys: possibleKeys.filter((v, i, a) => a.indexOf(v) === i),\n      score: this.#order\n    };\n    m[method] = handlerSet;\n    curNode.#methods.push(m);\n    return curNode;\n  }\n  #getHandlerSets(node, method, nodeParams, params) {\n    const handlerSets = [];\n    for (let i = 0, len = node.#methods.length; i < len; i++) {\n      const m = node.#methods[i];\n      const handlerSet = m[method] || m[METHOD_NAME_ALL];\n      const processedSet = {};\n      if (handlerSet !== void 0) {\n        handlerSet.params = /* @__PURE__ */ Object.create(null);\n        handlerSets.push(handlerSet);\n        if (nodeParams !== emptyParams || params && params !== emptyParams) {\n          for (let i2 = 0, len2 = handlerSet.possibleKeys.length; i2 < len2; i2++) {\n            const key = handlerSet.possibleKeys[i2];\n            const processed = processedSet[handlerSet.score];\n            handlerSet.params[key] = params?.[key] && !processed ? params[key] : nodeParams[key] ?? params?.[key];\n            processedSet[handlerSet.score] = true;\n          }\n        }\n      }\n    }\n    return handlerSets;\n  }\n  search(method, path) {\n    const handlerSets = [];\n    this.#params = emptyParams;\n    const curNode = this;\n    let curNodes = [curNode];\n    const parts = splitPath(path);\n    const curNodesQueue = [];\n    for (let i = 0, len = parts.length; i < len; i++) {\n      const part = parts[i];\n      const isLast = i === len - 1;\n      const tempNodes = [];\n      for (let j = 0, len2 = curNodes.length; j < len2; j++) {\n        const node = curNodes[j];\n        const nextNode = node.#children[part];\n        if (nextNode) {\n          nextNode.#params = node.#params;\n          if (isLast) {\n            if (nextNode.#children[\"*\"]) {\n              handlerSets.push(\n                ...this.#getHandlerSets(nextNode.#children[\"*\"], method, node.#params)\n              );\n            }\n            handlerSets.push(...this.#getHandlerSets(nextNode, method, node.#params));\n          } else {\n            tempNodes.push(nextNode);\n          }\n        }\n        for (let k = 0, len3 = node.#patterns.length; k < len3; k++) {\n          const pattern = node.#patterns[k];\n          const params = node.#params === emptyParams ? {} : { ...node.#params };\n          if (pattern === \"*\") {\n            const astNode = node.#children[\"*\"];\n            if (astNode) {\n              handlerSets.push(...this.#getHandlerSets(astNode, method, node.#params));\n              astNode.#params = params;\n              tempNodes.push(astNode);\n            }\n            continue;\n          }\n          if (part === \"\") {\n            continue;\n          }\n          const [key, name, matcher] = pattern;\n          const child = node.#children[key];\n          const restPathString = parts.slice(i).join(\"/\");\n          if (matcher instanceof RegExp) {\n            const m = matcher.exec(restPathString);\n            if (m) {\n              params[name] = m[0];\n              handlerSets.push(...this.#getHandlerSets(child, method, node.#params, params));\n              if (Object.keys(child.#children).length) {\n                child.#params = params;\n                const componentCount = m[0].match(/\\//)?.length ?? 0;\n                const targetCurNodes = curNodesQueue[componentCount] ||= [];\n                targetCurNodes.push(child);\n              }\n              continue;\n            }\n          }\n          if (matcher === true || matcher.test(part)) {\n            params[name] = part;\n            if (isLast) {\n              handlerSets.push(...this.#getHandlerSets(child, method, params, node.#params));\n              if (child.#children[\"*\"]) {\n                handlerSets.push(\n                  ...this.#getHandlerSets(child.#children[\"*\"], method, params, node.#params)\n                );\n              }\n            } else {\n              child.#params = params;\n              tempNodes.push(child);\n            }\n          }\n        }\n      }\n      curNodes = tempNodes.concat(curNodesQueue.shift() ?? []);\n    }\n    if (handlerSets.length > 1) {\n      handlerSets.sort((a, b) => {\n        return a.score - b.score;\n      });\n    }\n    return [handlerSets.map(({ handler, params }) => [handler, params])];\n  }\n};\nexport {\n  Node\n};\n","export const FOO = 'BAR'\n"],"names":["modules","entry","mainEntry","parcelRequireName","externals","distDir","publicUrl","devServer","globalObject","globalThis","self","window","global","previousRequire","importMap","i","cache","nodeRequire","module","require","bind","newRequire","name","jumped","currentRequire","err","Error","code","localRequire","resolve","x","id","Module","call","exports","res","isParcelRequire","moduleName","bundle","parent","register","Object","defineProperty","get","length","mainExports","define","amd","__globalThis","parcelHelpers","defineInteropFlag","_hono","_indexTs","app","Hono","onError","c","console","error","text","notFound","log","req","url","url404","URL","env","ASSETS","fetch","use","next","FOO","default","export","_honoJs","_honoBaseJs","_indexJs","_indexJs1","_indexJs2","HonoBase","constructor","options","router","SmartRouter","routers","RegExpRouter","TrieRouter","_composeJs","_contextJs","_routerJs","_constantsJs","_urlJs","notFoundHandler","errorHandler","getResponse","newResponse","body","post","put","delete","patch","all","on","getPath","_basePath","routes","allMethods","METHODS","METHOD_NAME_ALL_LOWERCASE","forEach","method","args1","args","handler","path","handlers","p","flat","m","map","toUpperCase","arg1","unshift","METHOD_NAME_ALL","strict","optionsWithoutStrict","assign","getPathNoStrict","clone","route","subApp","basePath","r","compose","COMPOSED_HANDLER","mergePath","mount","applicationHandler","replaceRequest","optionHandler","request","getOptions","options2","Array","isArray","executionContext","executionCtx","mergedPath","pathPrefixLength","pathname","slice","Request","raw","add","push","Response","matchResult","match","Context","Promise","then","resolved","finalized","catch","composed","context","rest","input","requestInit","Env","toString","test","fire","addEventListener","event","respondWith","middleware","onNotFound","index","dispatch","isError","routeIndex","interopDefault","a","__esModule","value","exportAll","source","dest","keys","key","prototype","hasOwnProperty","enumerable","destName","TEXT_PLAIN","_requestJs","_htmlJs","setHeaders","headers","set","HonoRequest","status","_res","k","v","entries","cookies","getSetCookie","cookie","append","render","content","html","setLayout","layout","getLayout","setRenderer","renderer","header","toLocaleLowerCase","Headers","toLowerCase","Map","var","fromEntries","data","arg","v2","json","object","JSON","stringify","resolveCallback","HtmlEscapedCallbackPhase","Stringify","html2","redirect","location","String","_bodyJs","tryDecodeURIComponent","str","tryDecode","decodeURIComponent_","bodyCache","param","paramKey","decoded","query","getQueryParam","queries","getQueryParams","headerData","parseBody","parsedBody","cachedBody","anyCachedKey","arrayBuffer","blob","formData","addValidatedData","target","valid","matchedRoutes","routePath","create","dot","contentType","startsWith","parseFormData","convertFormDataToBodyData","form","endsWith","handleParsingAllValues","includes","handleParsingNestedValues","nestedForm","split","key2","File","checkOptionalParameter","getPattern","getQueryStrings","splitPath","splitRoutingPath","paths","shift","groups","extractGroupsFromPath","replaceGroupMarks","replace","mark","j","patternCache","label","cacheKey","RegExp","decoder","tryDecodeURI","decodeURI","start","indexOf","charCode","charCodeAt","queryIndex","result","at","base","sub","segments","results","segment","optionalSegment","filter","_decodeURI","_getQueryParam","multiple","encoded","keyIndex2","trailingKeyCode","valueIndex","endIndex","isNaN","keyIndex","nextKeyIndex","decodeURIComponent","escapeToBuffer","resolveCallbackSync","stringBufferToString","BeforeStream","Stream","callbacks","escapedString","isEscaped","escapeRe","buffer","resolvedBuffer","buf","escape","search","lastIndex","substring","phase","preserveCallbacks","resStr","Boolean","str2","MESSAGE_MATCHER_IS_ALREADY_BUILT","UnsupportedPathError","_nodeJs","_trieJs","emptyParam","nullMatcher","wildcardRegExpCache","buildWildcardRegExp","_","metaChar","findMiddleware","sort","b","handlerMap","paramCount","re","len","path2","matchers","method2","matcher","staticMatch","concat","hasOwnRoute","ownRoute","buildMatcherFromPreprocessedRoutes","trie","Trie","handlerData","routesWithStaticPathFlag","isStaticA","pathA","isStaticB","pathB","staticMap","paramAssoc","pathErrorCheckOnly","h","insert","e","PATH_ERROR","paramIndexMap","regexp","indexReplacementMap","paramReplacementMap","buildRegExp","len2","len3","Node","LABEL_REG_EXP_STR","TAIL_WILDCARD_REG_EXP_STR","Symbol","regExpMetaChars","Set","compareKey","tokens","paramMap","node","token","restTokens","pattern","regexpStr","some","varIndex","buildRegExpStr","strList","childKeys","has","join","replaced","captureIndex","handlerIndex","paramIndex","Number","init","i2","activeRouter","emptyParams","children","possibleKeys","score","curNode","parts","nextP","pattern2","handlerSet","nodeParams","params","handlerSets","processedSet","processed","curNodes","curNodesQueue","part","isLast","tempNodes","nextNode","astNode","child","restPathString","exec","componentCount","targetCurNodes","_default","parcelRequire375b"],"version":3,"file":"index.js.map","sourceRoot":"../../../"}